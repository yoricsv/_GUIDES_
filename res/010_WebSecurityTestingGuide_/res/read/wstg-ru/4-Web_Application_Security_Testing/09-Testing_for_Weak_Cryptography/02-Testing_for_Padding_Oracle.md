---

layout: col-document
title: WSTG - Latest
tags: WSTG

---

{% include breadcrumb.html %}
# Тестирование оракула дополнений

|ID          |
|------------|
|WSTG-CRYP-02|

## Обзор

Оракул дополнения (англ.: padding oracle) — это функция приложения, которая расшифровывает зашифрованные данные (шифротекст), предоставленные клиентом, например, внутреннее состояние сессии, хранящееся на клиенте, и выдает состояние достоверности дополнения после расшифровки. Существование оракула дополнения позволяет злоумышленнику расшифровывать шифротекст и шифровать произвольные данные, не зная ключа, используемого для этих криптографических операций. Это может привести к утечке конфиденциальных данных или к уязвимостям эскалации привилегий, если приложение полагается на целостность зашифрованных данных.

Блочные шифры шифруют данные только блоками определённого размера. Размеры блоков, используемые обычными шифрами, составляют 8 и 16 байт. Данные, размер которых не кратен размеру блока используемого шифра, должны быть дополнены определённым образом, чтобы при расшифровке можно было удалить дополнение. Обычно используемая схема заполнения — PKCS#7. Она дополняет оставшиеся байты значением длины дополнения.

### Пример 1

Если дополнение имеет длину 5 байтов, значение байта `0x05` повторяется пять раз после открытого текста.

Условие ошибки возникает, если дополнение не соответствует синтаксису используемой схемы дополнения. Оракул дополнения возникает, если приложение пропускает это конкретное условие ошибки дополнения для шифротекста, предоставленного клиентом. Это может произойти посредством прямого разглашения исключений (например, `BadPaddingException` в Java); незначительных различий в ответах, отправляемых клиенту; или по другому побочному каналу, например по поведению задержек.

Определённые режимы работы блочных шифров допускают атаки с инверсией битов в шифротексте, что приводит к тому, что он также инвертируется в открытом тексте. Инверсия бита в n-м блоке шифротекста CBC приводит к тому, что тот же бит в (n+1)-м блоке инвертируется в расшифрованных данных. N-й блок расшифрованного шифротекста в результате этой манипуляции искажается.

Атака оракула дополнения позволяет злоумышленнику расшифровывать шифротекст, не зная ключа шифрования и используемого шифра, отправляя специально подобранный шифротекст оракулу дополнения, и наблюдая за возвращаемыми им результатами. Это приводит к потере конфиденциальности зашифрованных данных. Например. в случае данных сессии, хранящихся на стороне клиента, злоумышленник может получить информацию о внутреннем состоянии и структуре приложения.

Атака оракула дополнения также позволяет злоумышленнику шифровать произвольные открытые тексты без знания используемого ключа и шифра. Если приложение предполагает, что целостность и подлинность расшифрованных данных гарантированы, злоумышленник может иметь возможность манипулировать внутренним состоянием сессии и, возможно, получить более высокие полномочия.

## Задачи тестирования

- Найти зашифрованные сообщения, которые полагаются на дополнение.
- Попытаться нарушить дополнение зашифрованных сообщений и проанализировать выданные сообщения об ошибках для дальнейшего анализа.

## Как тестировать

### Тестирование методом чёрного ящика

Сначала необходимо определить возможные входные точки для оракула дополнения. Как правило, должны быть соблюдены следующие условия:

1. Данные зашифрованы. Хорошими кандидатами являются значения, которые кажутся случайными.
2. Используется блочный шифр. Длина декодированного (часто используется Base64) шифротекста кратна обычным размерам блоков шифра, например, 8 или 16 байт. Различные шифротексты (например, собранные в разных сессиях или изменением их состояния) имеют общий делитель для длины.

#### Пример 2

`Dg6W8OiWMIdVokIDH15T/A==` — результат Base64-декодирования из `0e 0e 96 f0 e8 96 30 87 55 a2 42 03 1f 5e 53 fc`. Кажется случайным и имеет длину 16 байт.

Если найден такой кандидат для входного значения, надо выяснить поведение приложения в отношении побитового вмешательства в зашифрованное значение. Обычно это значение, закодированное в Base64, будет включать вектор инициализации (IV), добавленный перед шифротекстом. Учитывая открытый текст *`p`* и шифр с размером блока *`n`*, число блоков будет *`b = ceil( length(b) / n)`*. Длина зашифрованной строки будет *`y=(b+1)*n`* из-за вектора инициализации. Чтобы убедиться в наличии оракула, декодируйте строку, инвертируйте последний бит предпоследнего блока *`b-1`* (самый младший бит байта в *`y-n-1`*), перекодируйте и отправьте. Затем декодируйте исходную строку, инвертируйте последний бит блока *`b-2`* (младший значащий бит байта в *`y-2*n-1`*), перекодируйте и отправьте.

Если известно, что зашифрованная строка представляет собой один блок (IV хранится на сервере или приложение применяет плохую практику жёстко закодированного IV), необходимо инвертировать несколько бит по очереди. Альтернативным вариантом может быть добавление случайного блока и инверсия битов, чтобы последний байт добавленного блока принимал все возможные значения (от 0 до 255).

Тесты и базовое значение должны вызывать по крайней мере три разных состояния во время и после расшифровки:

- Шифротекст расшифровывается, результирующие данные верны.
- Шифротекст расшифровывается, результирующие данные искажаются и вызывают некоторое исключение или обработку ошибок в логике приложения.
- Расшифровка шифротекста завершается неудачей из-за ошибок дополнения.

Внимательно сравните ответы. Особенно ищите исключения и сообщения, в которых говорится, что что-то не так с дополнением. Если такие сообщения появляются, приложение содержит оракул дополнения. Если три различных состояния, описанных выше, наблюдаются неявно (различные сообщения об ошибках, побочный канал по времени), существует высокая вероятность того, что в этой точке присутствует оракул дополнения. Попробуйте провести атаку, чтобы убедиться в этом.

##### Пример 3

- ASP.NET выдаёт `System.Security.Cryptography.CryptographicException: Padding is invalid and cannot be removed.` если нарушено дополнение расшифрованного шифротекста.
- В таких случаях Java выдаёт `javax.crypto.BadPaddingException`.
- Ошибки расшифровки и тому подобное могут быть признаками оракула дополнения.

> Безопасная реализация будет проверять целостность и вызывать только два ответа: `ok` и `failed`. Без побочных каналов, которые можно использовать для определения условия внутренней ошибки.

### Тестирование методом серого ящика

Убедитесь, что все места, где зашифрованные данные от клиента, которые должны быть известны только серверу, расшифровываются. Такой код должен соответствовать следующим условиям:

1. Целостность зашифрованного текста должна быть проверена с помощью защищённого механизма, такого как HMAC, или аутентифицированных режимов работы шифрования, таких как GCM или CCM.
2. Все условия ошибок при расшифровке и дальнейшей обработке обрабатываются единообразно.

### Пример 4

[Визуализация процесса расшифровки](https://erlend.oftedal.no/blog/poet/)

## Инструменты

- [Bletchley](https://code.blindspotsecurity.com/trac/bletchley)
- [PadBuster](https://github.com/GDSSecurity/PadBuster)
- [Padding Oracle Exploitation Tool (POET)](http://netifera.com/research/)
- [Poracle](https://github.com/iagox86/Poracle)
- [python-paddingoracle](https://github.com/mwielgoszewski/python-paddingoracle)

## Ссылки

- [Wikipedia - Padding Oracle Attack](https://en.wikipedia.org/wiki/Padding_oracle_attack)
- [Juliano Rizzo, Thai Duong, "Practical Padding Oracle Attacks"](https://www.usenix.org/event/woot10/tech/full_papers/Rizzo.pdf)
