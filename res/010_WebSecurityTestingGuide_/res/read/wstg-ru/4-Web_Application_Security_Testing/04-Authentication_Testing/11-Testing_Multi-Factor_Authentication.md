---

layout: col-document
title: WSTG - Latest
tags: WSTG

---

{% include breadcrumb.html %}
# Тестирование мультифакторной аутентификации (MFA)

|ID          |
|------------|
|WSTG-AUTH-11|

## Обзор

Многие приложения реализуют многофакторную аутентификацию (МФА, англ.: MFA) в качестве дополнительного уровня защиты процесса входа в систему. МФА также называют двухфакторной аутентификацией (2FA) или двухшаговой верификацией (2SV), хотя это не совсем одно и то же. МФА означает, что пользователю нужно указать *как минимум* два разных [фактора аутентификации](#типы-мфа) при входе в систему.

МФА увеличивает сложность как самой аутентификации, так и других областей, связанных с безопасностью (таких как управление учётными данными и восстановление пароля), а это означает, что очень важно правильно и надёжно реализовать её.

## Задачи тестирования

- Определить тип МФА, используемой приложением.
- Определить насколько надёжна и безопасна реализация МФА.
- Попытаться обойти МФА.

## Как тестировать

### Типы МФА

МФА означает, что для аутентификации требуются *как минимум* два из следующих факторов:

| Фактор | Примеры |
|--------|----------|
| То, что вы знаете | Пароли, PIN и контрольные вопросы. |
| То, что у вас есть | Аппаратные или программные токены, сертификаты, email*, SMS и звонки по телефону. |
| То, кем вы являетесь | Отпечатки пальцев, распознавание лица и прочие биометрические и поведенческие факторы. |
| То, где вы находитесь | Диапазоны IP-адресов источника и геолокация. |

\* Электронная почта представляет собой «то, что у вас есть», только если сама учётная запись email защищена с помощью МФА. Таким образом, её следует считать более слабым фактором, чем другие альтернативы, такие как сертификаты или TOTP (в некоторых определениях её не принимают в качестве фактора МФА).

Обратите внимание, что требование нескольких факторов одного типа (например, необходимость как пароля, так и PIN-кода) **не является МФА**, хотя и может обеспечить некоторые преимущества в защите по сравнению с простым паролем и может рассматриваться как двухшаговая верификация (2SV).

Из-за сложности реализации проверки биометрии в браузерах этот фактор редко используется для web-приложений, хотя его начинают применять благодаря таким стандартам, как WebAuthn. Наиболее распространённым вторым фактором является «то, что у вас есть».

### Проверка обхода МФА

Первым шагом для тестирования МФА является определение всех функций аутентификации в приложении, которые могут включать:

- главную страницу входа в систему;
- важные для безопасности функции (например, отключение МФА или изменение пароля);
- поставщиков федеративного входа (OIDC, SAML и т.п.);
- конечные точки API (как из основного web-интерфейса, так и из мобильных приложений);
- альтернативные протоколы (не HTTP);
- функциональность тестирования и отладки.

Необходимо проверить все возможные методы входа, чтобы убедиться, что везде применяется МФА. Если некоторые методы её не требуют, то они могут стать простым способом обойти МФА.

Если аутентификация проводится в несколько шагов, то её можно обойти, выполнив первый шаг (введя имя пользователя и пароль), а затем перебором (англ.: forced browse) найти нужную страницу приложения или сделать прямой запрос к API, минуя второй шаг (ввода кода МФА).

В некоторых случаях также может быть реализован преднамеренный обход МФА, например:

- с определённых IP-адресов (которые можно подделать с помощью HTTP-заголовка `X-Forwarded-For`);
- когда установлен определённый HTTP-заголовок (например, нестандартный, такой как `X-Debug`);
- для определённой учётной записи (например, root или break glass).

Если приложение поддерживает как локальный, так и федеративный вход, то при отсутствии чёткого разделения между этими двумя типами учётных записей можно обойти МФА. Например, если пользователь регистрирует локальную учётную запись и настраивает для неё МФА, но не настроил МФА для своей учётной записи в системе федеративного входа, то злоумышленник может повторно зарегистрировать (или связать) федеративную учётную запись на целевое приложение с тем же email, скомпрометировав учётную запись пользователя у поставщика федеративного входа.

Наконец, если МФА реализован в системе, отличной от основного приложения (например, на обратном прокси-сервере, чтобы защитить устаревшее приложение, которое исходно МФА не поддерживало), то можно обойти её, подключившись напрямую к серверу приложений бэкенда, как описано в разделе [архитектуры приложений](../01-Information_Gathering/10-Map_Application_Architecture.md#сети-доставки-контента-cdn).

### Проверка управления МФА

Функциональность, используемая для управления МФА из учётной записи пользователя, должна быть протестирована на наличие уязвимостей, отвечая в том числе на следующие вопросы:

- Требуется ли повторная аутентификация пользователя для удаления или изменения настроек МФА?
- Уязвимы ли функции управления МФА для [CSRF](../06-Session_Management_Testing/05-Testing_for_Cross_Site_Request_Forgery.md)?
- Можно ли изменить настройки MFA других пользователей с помощью [уязвимостей IDOR](../05-Authorization_Testing/04-Testing_for_Insecure_Direct_Object_References.md)?

### Проверка параметров восстановления МФА

Многие приложения предоставляют пользователям возможность восстановить доступ к своей учётной записи, если они не могут пройти аутентификацию с помощью второго фактора (например, потеряв телефон). Эти механизмы часто могут представлять собой значительную уязвимость приложения, поскольку они позволяют обойти второй фактор аутентификации.

#### Коды восстановления

Некоторые приложения предоставляют пользователю список кодов восстановления при включении МФА, которые можно использовать для входа в систему. Они должны быть проверены, чтобы убедиться, что:

- они достаточно длинные и сложные, чтобы защищать от атак перебором;
- они безопасно генерируются;
- их можно использовать только один раз;
- предусмотрена защита от перебора (например, блокировка учётной записи);
- пользователь получает уведомление об использовании кода (по email, SMS и т.д.).

Дополнительную информацию см. в разделе [Резервные коды в Памятке по забытым паролям](https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html#backup-codes).

#### Процесс сброса МФА

Если приложение реализует процесс сброса МФА, оно должно быть протестировано таким же образом, как и [процесс сброса пароля](09-Testing_for_Weak_Password_Change_or_Reset_Functionalities.md). Важно, чтобы этот процесс был *как минимум* таким же защищённым, как и реализация МФА для приложения.

#### Альтернативные способы аутентификации

Некоторые приложения позволяют пользователю подтвердить свою личность с помощью других способов, таких как использование [контрольных вопросов](08-Testing_for_Weak_Security_Question_Answer.md). Обычно они представляет собой серьёзную уязвимость, поскольку «секретные» вопросы обеспечивают гораздо более низкий уровень защиты, чем МФА.

### Одноразовые пароли

Наиболее распространённая форма МФА — одноразовые пароли (англ.: One-Time Passwords, OTP), которые обычно представляют собой шестизначные числовые коды (хотя они могут быть длиннее или короче). Они могут формироваться как сервером, так и пользователем (например, в приложении-аутентификаторе), либо могут быть сгенерированы на сервере и отправлены пользователю. Существуют различные способы доставки OTP пользователю, в том числе:

| Тип | Описание |
|------|-------------|
| Одноразовый пароль на основе HMAC (HOTP) | Генерирует код на основе HMAC секрета и общего счётчика. |
| Одноразовый пароль, основанный на времени (TOTP) | Генерирует код на основе HMAC секрета и текущего времени. |
| Email | Отправляет код по электронной почте. |
| SMS | Отправляет код по SMS. |
| Телефон | Отправляет код с помощью голосового вызова на номер телефона. |

OTP обычно вводится после того, как пользователь ввёл имя и пароль. Должны быть проведены различные проверки, в том числе:

- Блокируется ли учётная запись после нескольких неудачных попыток МФА?
- Блокируется ли IP-адрес пользователя после нескольких неудачных попыток МФА для разных учётных записей?
- Регистрируются ли неудачные попытки МФА в журнале аудита?
- Уязвима ли форма к атакам инъекции, включая [SQL-инъекцию символов подстановки](../07-Input_Validation_Testing/05-Testing_for_SQL_Injection.md#sql-инъекция-с-символами-подстановки)?

В зависимости от типа используемых OTP, существуют также некоторые другие специфические проверки, которые следует провести:

- Как OTP отправляются пользователю (email, SMS, телефон и т.д.)
    - Реализовано ли ограничение по частоте запросов, чтобы избежать трат на SMS/телефонный спам?
- Насколько стойки OTP (длина и ключевое пространство)?
- Как долго действуют OTP?
- Могут ли одновременно действовать несколько OTP?
- Можно ли использовать OTP более одного раза?
- Связан ли OTP с учётной записью пользователя или по нему можно пройти аутентификацию с помощью других учётных записей?

#### HOTP и TOTP

Коды HOTP и TOTP основаны на общем секрете, который совместно используется сервером и пользователем. Код TOTP обычно предоставляется пользователю в виде QR-кода, который он сканирует с помощью приложения-аутентификатора (хотя его также можно ввести в виде строки вручную).

Если секрет генерируется на сервере, следует убедиться, что он достаточно длинный и сложный (в [RFC 4226](https://www.rfc-editor.org/rfc/rfc4226#section-4) рекомендуется не менее 160 бит) и что он генерируется с использованием [криптостойкой случайной функции](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#secure-random-number-generation).

Там, где секрет может вводиться пользователем, должна устанавливаться достаточная минимальная длина, и ввод должен контролироваться на предмет обычных атак инъекции.

Коды TOTP обычно действительны в течение 30 секунд, но некоторые приложения предпочитают принимать несколько кодов (например, предыдущий, текущий и следующий), чтобы учесть разницу между системным временем на сервере и на устройстве пользователя. Некоторые приложения могут разрешать несколько кодов по обе стороны от текущего, что может облегчить злоумышленнику угадывание или перебор кода. В таблице ниже показана вероятность успешного подбора кода OTP, основанная на предположении, что злоумышленник может выполнить 10 запросов в секунду для приложений, которые принимают либо только текущий код, либо несколько кодов (см. [эту статью](https://www.codasecurity.co.uk/articles/mfa-testing#case-study---brute-forcing-totp) о расчётах, приведённых в таблице).

| Количество действующих кодов TOTP | Вероятность успеха после 1 часа | Вероятность успеха после 4 часов | Вероятность успеха после 12 часов | Вероятность успеха после 24 часов |
|-------------|---------------------------|----------------------------|-----------------------------|-----------------------------|
| 1 | 4%  | 13% | 35% | 58% |
| 3 | 10% | 35% | 72% | 92% |
| 5 | 16% | 51% | 88% | 99% |
| 7 | 22% | 63% | 95% | 99% |

#### Email, SMS и телефон

В тех случаях, когда коды генерируются сервером и отправляются клиенту, необходимо учитывать следующие вопросы:

- Достаточно ли защищён канал передачи (email, SMS или голос) для приложения?
- Являются ли коды достаточно длинными и сложными?
- Генерируются ли коды с использованием [криптостойкой случайной функции](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#secure-random-number-generation)?
- Как долго действуют коды?
- Действительны ли одновременно несколько кодов или генерация нового кода делает предыдущий недействительным?
    - Можно ли это использовать для блокировки доступа к учётной записи посредством многократного запроса кодов?
- Достаточно ли ограничивается частота запросов, чтобы злоумышленник не запрашивал слишком много кодов?
    - Большое количество кодов, отправляемых по электронной почте, может привести к блокировке сервера за отправку спама.
    - Большое количество SMS или голосовых вызовов может быть затратным или причинять беспокойство пользователю.

### Мобильные приложения и Push-уведомления

Альтернативным подходом к OTP-кодам является отправка push-уведомлений на мобильный телефон пользователя, которые он может либо одобрить, либо отклонить. Этот метод менее распространён, так как требует от пользователя установки аутентификатора для конкретного приложения.

Для правильной оценки защищённости этого подхода требуется расширить область тестирования, чтобы охватить как мобильное приложение, так и все вспомогательные API или сервисы, используемые им, что часто выходит за рамки традиционного тестирования web-приложения. Однако есть пара простых проверок, которые можно провести без тестирования мобильного приложения, в том числе:

- Даёт ли уведомление достаточно контекста (IP-адрес, местоположение и т.д.), чтобы пользователь мог принять обоснованное решение о том, одобрять его или отклонять?
- Реализован ли какой-либо механизм запроса и ответа (например, предоставление кода на сайте, который пользователь должен ввести в приложение?
- Реализованы ли какие-либо ограничения частоты запросов или механизмы, позволяющие предотвратить рассылку пользователю спама с уведомлениями в надежде, что он одобрит их не глядя?

### Фильтрация по IP-адресу и местоположению

Одним из факторов, который иногда используется в МФА, является местоположение («то, где вы находитесь»), хотя вопрос о том, является ли он уместным для аутентификации, является спорным. В контексте web-приложения это обычно означает ограничение доступа к определённым IP-адресам или отказ от запроса второго фактора при подключении с доверенного IP-адреса. Обычным сценарием для таких случаев будет аутентификация пользователей только с паролем при подключении из диапазонов IP-адресов офиса, но при подключении из другого места требуется код OTP.

В зависимости от реализации пользователь может подделать доверенный IP-адрес, установив заголовок `X-Forwarded-For`, что позволит ему обойти эту проверку. Обратите внимание, что если приложение некорректно нейтрализует содержимое этого заголовка, то можно провести атаку, например, SQL-инъекции. Если приложение поддерживает IPv6, это также следует проверить, чтобы убедиться, что к этим подключениям применяются соответствующие ограничения.

Кроме того, доверенные IP-адреса должны быть проверены, чтобы убедиться, что они не представляют каких-либо уязвимостей, например, не включают ли они:

- IP-адреса, к которым могут получить доступ недоверенные пользователи (например, гостевые беспроводные сети в офисе).
- Динамически назначаемые IP-адреса, которые могут меняться.
- Диапазоны общедоступных сетей, в которых злоумышленник может разместить собственную систему (например, Azure, GCP, AWS и пр.).

### Сертификаты и смарт-карты

Безопасность транспортного уровня (TLS) обычно используется для шифрования трафика между клиентом и сервером, а также для предоставления клиенту механизма аутентификации сервера (путём сравнения  общепринятого имени (англ.: Common Name, CN) или альтернативного имени субъекта (англ.: Subject Alternative Name, SAN) в сертификате на запрошенный домен). Однако он также может предоставить серверу механизм аутентификации клиента, известный как проверка подлинности сертификата клиента или взаимный TLS (mTLS). Подробное обсуждение mTLS выходит за рамки данного Руководства, но основной принцип заключается в том, что пользователь представляет сертификат (хранящийся либо на его компьютере, либо на смарт-карте), который проверяется сервером.

Первым шагом при тестировании является определение того, ограничивает ли целевое приложение удостоверяющие центры (УЦ), которым доверено выпускать сертификаты. Эту информацию можно получить с помощью различных инструментов или вручную, изучив TLS-рукопожатие. Самый простой способ — использовать `s_client` в OpenSSL:

```bash
$ openssl s_client -connect example:443
[...]
Acceptable client certificate CA names
C = US, ST = Example, L = Example, O = Example Org, CN = Example Org Root Certificate Authority
Client Certificate Types: RSA sign, DSA sign, ECDSA sign
```

Если ограничений нет, то можно проводить аутентификацию с использованием сертификата от другого УЦ. Если ограничения существуют, но они плохо реализованы, возможно, удастся создать локальный УЦ с корректным именем (в примере выше "Example Org Root Certificate Authority") и использовать этот новый УЦ для подписи клиентских сертификатов.

Если можно получить действительный сертификат, то также следует убедиться, что сертификат может быть использован только тем пользователем, для которого он выдан (т.е. нельзя использовать сертификат, выданный Алисе, для аутентификации в учётной записи Боба). Кроме того, следует проверить сертификаты, чтобы убедиться, что срок их действия не истёк и они не были отозваны.

## Связанные сценарии тестирования

- [Тестирование механизма блокировки](03-Testing_for_Weak_Lock_Out_Mechanism.md)
- [Тестирование функций изменения или сброса пароля](09-Testing_for_Weak_Password_Change_or_Reset_Functionalities.md)

## Меры защиты

Убедитесь, что:

- МФА реализована для всех релевантных учётных записей и функций в приложениях.
- Поддерживаемые методы МФА подходят для приложения.
- Механизмы, используемые для реализации МФА, должным образом защищены от атак перебором.
- Для всех действий, связанных с МФА, предусмотрен соответствующий аудит и ведение журнала событий.

Дополнительные рекомендации в [OWASP Multi-Factor Authentication Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Multifactor_Authentication_Cheat_Sheet.html).

## Ссылки

- [OWASP Multi-Factor Authentication Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Multifactor_Authentication_Cheat_Sheet.html)
