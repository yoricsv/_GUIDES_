---

layout: col-document
title: WSTG - Latest
tags: WSTG

---

{% include breadcrumb.html %}
# Архитектура приложения

|ID          |
|------------|
|WSTG-INFO-10|

## Обзор

Чтобы тщательно протестировать приложение и дать содержательные рекомендации по устранению выявленных проблем, важно понимать, что вы на самом деле тестируете. Кроме того, это может помочь определить, какие компоненты не входят в область тестирования.

Современные web-приложения могут сильно различаться по сложности: от простого скрипта, работающего на одном сервере, до очень сложного приложения, распределённого по десяткам различных систем и компонентов, написанного на разных языках. Также могут существовать дополнительные компоненты сетевого уровня, такие как межсетевые экраны или системы защиты от вторжений, которые могут оказать значительное влияние на тестирование.

## Задача тестирования

- Разобраться в архитектуре приложения и используемых технологиях.

## Как тестировать

При тестировании с точки зрения «чёрного ящика» важно попытаться создать чёткую картину того, как работает приложение и какие технологии и компоненты используются. В некоторых случаях можно протестировать определённые компоненты (например, web application firewall), в то время как другие можно определить, анализируя поведение приложения.

В приведённых ниже разделах представлен высокоуровневый обзор наиболее распространённых архитектурных компонентов, а также подробные сведения о том, как их можно распознать.

### Компоненты приложения

#### Web-сервер

Простые приложения могут работать на одном сервере, который можно идентифицировать с помощью шагов, описанных в разделе [Определение web-сервера](02-Fingerprint_Web_Server.md) данного руководства.

#### Platform-as-a-Service (PaaS)

В модели «Платформа как услуга» (PaaS) web-сервер и базовая инфраструктура управляются поставщиком услуг, а клиент несёт ответственность только за приложение, которое на нём развернуто. С точки зрения тестирования есть два основных отличия:

- Владелец приложения не имеет доступа к базовой инфраструктуре, поэтому не может напрямую устранять какие-либо проблемы.
- Тестирование инфраструктуры, скорее всего, выходит за рамки обязательств.

В некоторых случаях можно распознать PaaS, если приложение использует определённое доменное имя (например, приложения, развёрнутые в Azure App Services, будут иметь домен `*.azurewebsites.net`, хотя они также могут использовать и свои домены). В других случаях определить, используется ли PaaS трудно.

#### Serverless

В бессерверной модели разработчики предоставляют код, который выполняется непосредственно на платформе хостинга в виде отдельных функций, а не в виде традиционного более объёмного web-приложения, развёрнутого в webroot. Это делает его хорошо подходящим для архитектур, основанных на микросервисах. Как и в случае с PaaS, тестирование инфраструктуры, скорее всего, выйдет за рамки.

В некоторых случаях на использование бессерверного кода может указывать наличие определенных HTTP-заголовков. Например, функции AWS Lambda обычно возвращают следующие заголовки:

```http
X-Amz-Invocation-Type
X-Amz-Log-Type
X-Amz-Client-Context
```

Azure Functions менее очевидны. Обычно они возвращают заголовок `Server: Kestrel`, но этого самого по себе недостаточно, чтобы быть уверенным, что это функция Azure App, а не какой-либо другой код, работающий на Kestrel.

#### Микросервисы

В архитектуре, основанной на микросервисах, приложения состоит из нескольких отдельных сервисов API, а не работает как монолитное приложение. Сами сервисы часто запускаются внутри контейнеров (обычно с помощью Kubernetes) и могут использовать множество различных операционных систем и языков. Хотя они обычно находятся за одним API-шлюзом и доменом, использование нескольких языков (на что часто указывают сообщения об ошибках) может свидетельствовать о том, что используются микросервисы.

#### Статичное хранилище

Многие приложения хранят статичный контент на специализированных платформах хранения, а не размещают его непосредственно на самом web-сервере. Двумя наиболее распространёнными платформами являются Amazon S3 Buckets, и Azure Storage Accounts, и их можно легко идентифицировать по доменным именам:

- Amazon S3 Buckets это либо `BUCKET.s3.amazonaws.com` или `s3.REGION.amazonaws.com/BUCKET`
- Azure Storage Accounts это `ACCOUNT.blob.core.windows.net`

Эти учётные записи для хранения часто могут предоставлять доступ к чувствительным файлам, как описано в разделе [Тестирование облачного хранилища](../02-Configuration_and_Deployment_Management_Testing/11-Test_Cloud_Storage.md).

#### Базы данных

Большинство нетривиальных web-приложений используют какую-нибудь базу данных для хранения динамического содержимого. Часто определить базу данных можно с помощью:

- Сканирования портов сервера в поиске открытых, связанных с определёнными базами данных.
- Вызова сообщений об ошибках, связанных с SQL (или NoSQL) (или поиска существующих ошибок в [поисковой системе](../01-Information_Gathering/01-Conduct_Search_Engine_Discovery_Reconnaissance_for_Information_Leakage.md).

Там, где невозможно определить базу данных с полной уверенностью, часто можно сделать обоснованное предположение, основанное на других аспектах приложения:

- Windows, IIS и ASP.NET часто используют сервер Microsoft SQL..
- Во встроенных системах часто используют SQLite.
- PHP часто использует MySQL или PostgreSQL.
- APEX часто использует Oracle.

Это не строгие правила, но они, безусловно, могут дать разумную отправную точку, если нет более подробной информации.

#### Аутентификация

Большинство приложений имеют ту или иную форму аутентификации для пользователей. Существует несколько серверных модулей аутентификации, которые можно определить, например:

- Конфигурация web-сервера (включая файлы `.htaccess`) или указанные в скриптах пароли.
    - Обычно отображается как базовая HTTP-аутентификация (логин и пароль), на что указывает всплывающее окно в браузере и HTTP-заголовок  `WWW-Authenticate: Basic`.
- Локальные учётные записи пользователей в базе данных.
    - Обычно применяется в конечных точках API или формах приложения.
- Существующий источник централизованной аутентификации, такой как Active Directory или LDAP-сервер.
    - Может использовать NTLM-аутентификацию, на что указывает HTTP-заголовок `WWW-Authenticate: NTLM`.
    - Может применяться в форме web-приложения.
    - Может потребовать ввода имени пользователя в формате DOMAIN\username, или выдать раскрывающийся список доступных доменов.
- Единый вход (SSO) с внутренним или внешним поставщиком.
    - Обычно применяется OAuth, OpenID Connect или SAML.

Приложения могут предоставлять пользователю несколько вариантов аутентификации (например, регистрация локальной учётной записи или использование существующей в Google), и могут применять различные механизмы аутентификации для обычных пользователей и администраторов.

#### Сторонние сервисы и API

Почти все web-приложения включают сторонние ресурсы, которые загружаются или взаимодействуют с клиентом. Они могут включать в себя:

- [Активный контент](https://developer.mozilla.org/en-US/docs/Web/Security/Mixed_content#mixed_active_content) (например, скрипты, таблицы стилей, шрифты и фреймы).
- [Пассивный контент](https://developer.mozilla.org/en-US/docs/Web/Security/Mixed_content#mixed_passivedisplay_content) (например, изображения и видео).
- Внешние API.
- Кнопки социальных сетей.
- Рекламные сети.
- Платёжные шлюзы.

Эти ресурсы запрашиваются непосредственно браузером пользователя, поэтому их легко идентифицировать с помощью Инструментов разработчика или перехватывающего прокси. Хотя важно их идентифицировать (поскольку они могут повлиять на защищённость приложения), помните, что *обычно они не подлежат тестированию*, поскольку принадлежат третьим сторонам.

### Сетевые компоненты

#### Обратный прокси-сервер

Обратный прокси-сервер находится перед одним или несколькими внутренними серверами и перенаправляет запросы в соответствующее место назначения. Он может иметь различные функциональные возможности, например:

- Действует как [балансировщик нагрузки](#балансировщик-нагрузки) или [web application firewall](#web-application-firewall-waf).
- Разрешает размещать несколько приложений на одном IP-адресе или домене (в подкаталогах).
- Реализует фильтрацию по IP или другие ограничения.
- Кэширует содержимое серверной части для повышения производительности.

Не всегда возможно обнаружить обратный прокси-сервер (особенно если за ним стоит только приложение), но иногда его можно идентифицировать по:

- Несоответствию между сервером и приложением (например, заголовок `Server: nginx` с приложением на ASP.NET).
    - Иногда это может привести к уязвимостям [request smuggling](https://portswigger.net/web-security/request-smuggling).
- Дублирующимся заголовкам (особенно заголовок `Server`).
- Нескольким приложениям, размещённым на одном IP-адресе или домене (особенно если они написаны на разных языках).

#### Балансировщик нагрузки

Балансировщик нагрузки находится перед несколькими внутренними серверами и распределяет запросы между ними, чтобы обеспечить большую избыточность и вычислительные ресурсы для приложения.

Балансировщики нагрузки может быть трудно обнаружить, но иногда их можно идентифицировать, отправив несколько запросов и изучая ответы на предмет различий, таких как:

- Несогласованное (между компонентами) системное время.
- Различные внутренние IP-адреса или имена хостов в подробных сообщениях об ошибках.
- Разные адреса, возвращаются из-за уязвимости [Server-Side Request Forgery (SSRF)](../07-Input_Validation_Testing/19-Testing_for_Server-Side_Request_Forgery.md).

На них также может указывать наличие определённых файлов cookie (например, балансировщики нагрузки F5 BIG-IP создают файлы cookie с именем `BIGipServer`.

#### Сети доставки контента (CDN)

Сеть доставки контента (CDN) — это географически распределенный набор кэширующих прокси-серверов, предназначенный для повышения производительности и обеспечения дополнительной устойчивости web-сайта.

Обычно они конфигурируются путём указания общедоступного домена на серверы CDN, а затем настраивается CDN для подключения к соответствующим внутренним серверам (иногда называемым "origin").

Самый простой способ обнаружить CDN — поискать в WHOIS IP-адреса, в которые определяется домен. Если они принадлежат компании CDN (например, Akamai, Cloudflare или Fastly — см. [более полный список](https://en.wikipedia.org/wiki/Content_delivery_network#Notable_content_delivery_service_providers)) то похоже, что используется CDN.

При тестировании сайта за CDN вы должны иметь в виду следующие аспекты:

- IP-адреса и серверы принадлежат поставщику CDN поэтому, скорее всего, будут недоступны для тестирования инфраструктуры.
- Многие CDN также включают такие функции, как обнаружение ботов, ограничение частоты запросов и web application firewall.
- CDN обычно кэшируют контент, поэтому изменения, внесённые на серверную часть web-сайта, могут появиться не сразу.

Если сайт находится за CDN, то полезно идентифицировать внутренние серверы. Если у них нет надлежащего контроля доступа, то вы можете обойти CDN (и предлагаемые ею средства защиты), получив прямой доступ к внутренним серверам. Существует множество различных методов, которые могут позволить вам идентифицировать серверную часть:

- Электронные письма, отправляемые приложением, могут поступать непосредственно от внутреннего сервера, который может раскрыть свой IP-адрес.
- Перебор DNS (DNS grinding), передача зон или списки certificate transparency для домена могут выявить нужный поддомен.
- Сканирование диапазонов IP-адресов, которые используются компанией, может обнаружить внутренний сервер.
- Эксплуатация [подделки запросов на стороне сервера (SSRF)](../07-Input_Validation_Testing/19-Testing_for_Server-Side_Request_Forgery.md) может раскрыть IP-адрес сервера.
- Подробные сообщения об ошибках от приложения могут раскрывать IP-адреса или имена хостов.

### Средства безопасности

#### Межсетевой экран (МСЭ)

Большинство web-серверов будут защищены МСЭ с фильтрацией пакетов или проверкой состояния, который блокирует любой ненужный сетевой трафик. Чтобы обнаружить это, выполните сканирование портов сервера и изучите результаты.

Если большинство портов показаны как closed (т.е. они возвращают пакет `RST` в ответ на исходный пакет `SYN`) это говорит о том, что сервер не защищён МСЭ. Если порты отображаются как filtered (т.е. при отправке пакета `SYN` на неиспользуемый порт ответ не получен), то, скорее всего, установлен МСЭ.

Кроме того, если снаружи доступны неуместные сервисы (такие как SMTP, IMAP, MySQL и т.д.), это говорит о том, что либо МСЭ отсутствует, либо он настроен неправильно.

#### Система обнаружения и предотвращения сетевых вторжений

Сетевая система обнаружения вторжений (IDS) обнаруживает подозрительную или вредоносную активность на уровне сети (например, сканированием портов или уязвимостей) и выдаёт предупреждения. Система предотвращения вторжений (IPS) аналогична, но также принимает меры по предотвращению — обычно путём блокировки IP-адреса источника.

IPS обычно можно обнаружить, запустив инструменты автоматического сканирования (например, сканер портов) для целевого объекта и проверив, заблокирован ли исходный IP-адрес. Однако многие инструменты уровня приложений могут не обнаруживаться системой IPS (особенно если она не расшифровывает TLS).

#### Web Application Firewall (WAF)

Web Application Firewall (WAF) проверяет содержимое HTTP-запросов и блокирует те, которые кажутся подозрительными или вредоносными, или динамически применяет другие элементы управления, такие как CAPTCHA или ограничение частоты запросов. Обычно они основаны на наборе известных сигнатур и регулярных выражений, таких как [OWASP Core Rule Set](https://owasp.org/www-project-modsecurity-core-rule-set/). WAF могут быть эффективны для защиты от некоторых типов атак (таких как SQL-инъекции или XSS — межсайтовые скрипты), но менее эффективны против других типов (таких как проблемы, связанные с контролем доступа или бизнес-логикой).

WAF можно развернуть в нескольких местах, в том числе:

- На самом web-сервере.
- На отдельной виртуальной машине или оборудовании.
- В облаке перед внутренним сервером.

Поскольку WAF блокирует вредоносные запросы, его можно обнаружить, добавляя распространённые вектора атак к параметрам, и проверяя, блокируются ли они. Например, попробуйте добавить параметр `foo` со значением `'UNION SELECT 1` или `><script>alert(1)</script>`. Если эти запросы блокируются, это предполагает наличие WAF. Кроме того, сама страница блокировки может содержать информацию о конкретной используемой технологии. Наконец, некоторые WAF могут добавлять файлы cookie или HTTP-заголовки к ответам, которые могут выявить их присутствие.

Если используется облачный WAF, то его можно обойти путём прямого доступа к внутреннему серверу, используя те же методы, которые обсуждались выше в разделе `Сети доставки контента (CDN)`.
