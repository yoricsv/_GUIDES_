---

layout: col-document
title: WSTG - Latest
tags: WSTG

---

{% include breadcrumb.html %}
# Тестирование уязвимостей в OAuth

|ID          |
|------------|
|WSTG-ATHZ-05|

## Обзор

[OAuth2.0](https://oauth.net/2/) (далее именуемый OAuth) — это фреймворк авторизации, который позволяет клиенту получать доступ к ресурсам от имени своего пользователя.

Чтобы достичь этого, OAuth в значительной степени полагается на токены для связи между различными сущностями, причем каждая сущность играет свою [роль](https://datatracker.ietf.org/doc/html/rfc6749#section-1.1):

- **Владелец ресурса (англ.: Resource owner, RO):** субъект, предоставляющий доступ к ресурсу, владелец и в большинстве случаев сам пользователь
- **Сервер авторизации (англ.: Authorization Server, AS):** сервер, который хранит информацию об авторизации и предоставляет доступ
- **Клиентское приложение (англ.: Client):** приложение, запрашивающее доступ к ресурсу от имени Владельца ресурса. Клиентские приложения на основе их способности безопасно аутентифицироваться на сервере авторизации (AS) делятся на два [типа](https://oauth.net/2/client-types/):
    - **публичные (англ.: Public)** не хранят учётные данных на AS (*например,* такие как одностраничные web-приложения (англ.: single page application, SPA), мобильные приложения и т.д.)
    - **конфиденциальные (англ.: Confidential),** хранящие учётные данные на AS (*например*, сервисы бэкенда)
- **Сервер ресурсов (англ.: Resource Server, RS):** Приложение, которое обслуживает контент, к которому обращается клиент.

Поскольку OAuth отвечает за делегирование владельцем прав доступа клиентским приложениям, то он очень привлекателен для злоумышленников, а некорректные его реализации приводят к несанкционированному доступу к ресурсам и информации пользователей.

Чтобы предоставить доступ к клиентскому приложению, OAuth использует несколько [типов предоставления разрешений (англ.: authorization grant types)](https://oauth.net/2/grant-types/) для создания токена доступа (англ.: access token):

- [Код авторизации (англ.: Authorization Code)](https://oauth.net/2/grant-types/authorization-code/): используется как конфиденциальными, так и публичными клиентами для обмена кода авторизации на токен доступа, но рекомендуется только для конфиденциальных.
- [Ключ подтверждения для обмена кодами (англ.: Proof Key for Code Exchange (PKCE))](https://oauth.net/2/pkce/): PKCE расширяет возможности предыдущего типа, обеспечивая ему более надёжную защиту для использования публичными клиентами и улучшая положение конфиденциальных.
- [Учётные данные клиента (англ.: Client Credentials)](https://oauth.net/2/grant-types/client-credentials/): используется для связи между системами; здесь «пользователь» — система, запрашивающая доступ к своим собственным ресурсам, хранящимся на сервере ресурсов.
- [Код устройства (англ.: Device Code)](https://oauth.net/2/grant-types/device-code/): используется для устройств без браузера или с ограниченными возможностями ввода.
- [Токен обновления (англ.: Refresh Token)](https://oauth.net/2/grant-types/refresh-token/): токены, предоставляемые сервером авторизации, позволяющие клиентам обновлять токены доступа пользователей, когда они становятся недействительными или истекают. Этот тип предоставления разрешений используется в сочетании с одним из перечисленных выше.

Два потока признаны устаревшими в предстоящем релизе [OAuth2.1](https://oauth.net/2.1/), и их использование не рекомендуется:

- [Поток неявных разрешений (англ.: Implicit Flow)*](https://oauth.net/2/grant-types/implicit/): безопасная реализация PKCE выводит этот поток из употребления. До PKCE неявный поток использовался клиентскими приложениями, например, [одностраничными](https://ru.wikipedia.org/wiki/%D0%9E%D0%B4%D0%BD%D0%BE%D1%81%D1%82%D1%80%D0%B0%D0%BD%D0%B8%D1%87%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5), с тех пор как [CORS](https://developer.mozilla.org/ru/docs/Web/HTTP/CORS) ослабил [политику одного источника](https://developer.mozilla.org/ru/docs/Web/Security/Same-origin_policy) для взаимодействия между web-сайтами. Дополнительные сведения о том, почему неявное предоставление разрешений не рекомендуется, см. [здесь](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics#section-2.1.2).
- [Поток с предоставлением клиенту пароля (англ.: Resource Owner Password Credentials, ROPC)](https://oauth.net/2/grant-types/password/): используется для передачи пользователем учётных данных непосредственно в клиентское приложение, которое затем отправляет их на авторизацию для обмена на токен доступа. Сведения о том, почему этот поток не рекомендуется, см. [здесь](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics#section-2.4).

*: Неявный поток устарел только для OAuth, а в OpenID Connect (OIDC) он применяется для получения `id_tokens`. Будьте внимательны: неявный поток можно распознать, когда для получения токена доступа используется только конечная точка `/authorization`, никоим образом не полагаясь на конечную точку `/token`. Пример этого можно найти [здесь](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post).

*Обратите внимание, что потоки OAuth — сложная тема, и приведённое выше даёт очень краткое представление о её ключевых областях. Ссылки содержат дополнительную информацию о конкретных потоках.*

## Задача тестирования

- Определить, является ли реализация OAuth2 уязвимой, устаревшей или нестандартной.

## Как тестировать

### Тестирование на наличие устаревших потоков

Устаревшие потоки были удалены по соображениям безопасности и функциональности. Выявление их использования позволяет нам быстро проверить, подвержены ли они каким-либо угрозам, связанным с их эксплуатацией. Некоторые из них могут быть недоступны злоумышленнику, например, способ, которым клиентское приложение может использовать учётные данные пользователей. Это должно быть задокументировано и доведено до сведения внутренних инженерных команд.

Для публичных приложений, как правило, можно определить тип разрешения в запросе к конечной точке `/token`. Он указывается при обмене токенами в параметре `grant_type`.

В примере ниже показано предоставление кода авторизации с помощью PKCE.

```http
POST /oauth/token HTTP/1.1
Host: as.example.com
[...]

{
  "client_id":"example-client",
  "code_verifier":"example",
  "grant_type":"authorization_code",
  "code":"example",
  "redirect_uri":"http://client.example.com"
}
```

Соответствие между значениями параметра `grant_type` и типами предоставления разрешений, на которые они указывают:

- `password` — ROPC.
- `client_credentials` — учётные данные клиента.
- `authorization_code` — код авторизации.

Неявный тип потока не отображается в параметре `grant_type`, поскольку токен предоставляется в ответ на запрос конечной точки `/authorization`, и вместо этого может быть обнаружен с помощью `response_type`. Пример:

```http
GET /authorize
  ?client_id=<some_client_id>
  &response_type=token 
  &redirect_uri=https%3A%2F%2Fclient.example.com%2F
  &scope=openid%20profile%20email
  &state=<random_state>
```

На используемый поток OAuth указывают следующие параметры URL:

- `response_type=token` — неявный поток, т.к. клиент напрямую просит у сервера авторизации вернуть токен.
- `response_type=code` — поток с кодом авторизации, поскольку клиент просит у сервера авторизации вернуть код, который впоследствии будет обменен на токен.
- `code_challenge=sha256(xyz)`— расширение PKCE, т.к. ни один другой поток не использует этот параметр.

Ниже приведен пример запроса авторизации для потока кода авторизации с PKCE:

```http
GET /authorize
    ?redirect_uri=https%3A%2F%2Fclient.example.com%2F
    &client_id=<some_client_id>
    &scope=openid%20profile%20email
    &response_type=code
    &response_mode=query
    &state=<random_state>
    &nonce=<random_nonce>
    &code_challenge=<random_code_challenge>
    &code_challenge_method=S256 HTTP/1.1
Host: as.example.com
[...]
```

#### Публичные клиентские приложения

Для публичных клиентов рекомендуется поток с предоставлением кода авторизации с расширением PKCE. Запрос авторизации для потока кода авторизации с PKCE должен содержать `response_type=code` и `code_challenge=sha256(xyz)`.

Обмен токенами должен содержать тип предоставления разрешения `authorization_code` и `code_verifier`.

Для публичных клиентов не подходят следующие типы потоков:

- код авторизации без расширения PKCE
- учётные данные клиента
- неявный поток
- ROPC.

#### Конфиденциальные клиентские приложения

Для конфиденциальных клиентов рекомендуется поток с предоставлением кода авторизации. Также может применяться расширение PKCE.

Для конфиденциальных клиентов не подходят следующие типы потоков:

- учётные данные клиента (за исключением взаимодействий между системами — см. ниже)
- неявный поток
- ROPC.

##### Межсистемные взаимодействия

В ситуациях, когда взаимодействия с пользователем нет, а клиентами являются только конфиденциальными приложения, может использоваться поток с предоставлением учётных данных клиента.

Если вы знаете `client_id` и `client_secret`, можно получить токен, передав тип предоставления разрешений `client_credentials'.

```bash
$ curl --request POST \
  --url https://as.example.com/oauth/token \
  --header 'content-type: application/json' \
  --data '{"client_id":"<some_client_id>","client_secret":"<some_client_secret>","grant_type":"client_credentials"}' --proxy http://localhost:8080/ -k
```

### Раскрытие учётных данных

В зависимости от потока OAuth передает несколько типов учётных данных в качестве параметров URL.

Раскрытию учётных данных подвержены следующие токены:

- токен доступа (англ.: access token)
- токен обновления (англ.: refresh token)
- код авторизации (англ.: authorization code)
- запрос / ответ при обмене PKCE (англ.: code challenge / code verifier)

Из-за особенностей работы OAuth `authorization_code`, а также `code_challenge`, и `code_verifier` могут указываться в URL. В неявном потоке токен авторизации передаётся в URL если `response_mode` не установлен в значение [`form_post`](https://openid.net/specs/oauth-v2-form-post-response-mode-1_0.html). Это может привести к раскрытию запрошенного токена или кода в заголовке `Referrer`, в файлах журналов и прокси-серверах из-за того, что эти параметры передаются либо в запросе, либо во фрагменте.

Риск раскрытия токенов, который имеет неявный поток, намного выше, чем утечка `code` или других параметров `code_*`, поскольку они привязаны к конкретным клиентам и ими труднее воспользоваться в случае утечки.

Чтобы протестировать этот сценарий, используйте HTTP-прокси, например, OWASP ZAP, и перехватывайте трафик OAuth.

- Пройдите процесс авторизации и определите все учётные данные, присутствующие в URL.
- Если в страницу, связанную с потоком OAuth, включены какие-либо внешние ресурсы, проанализируйте запросы к ним. Учётные данные могут раскрываться в заголовке `Referrer`.

После OAuth-авторизации и использования приложения в истории запросов перехватывающего HTTP-прокси появится несколько запросов. Поищите по HTTP-заголовку Referrer (например, `Referer: https://idp.example.com/`) URL-адреса сервера авторизации и клиента в истории запросов.

Анализ метатегов Referrer в HTML (хотя этот тег [не поддерживается](https://caniuse.com/mdn-html_elements_meta_name_referrer) ни в одном браузере), или [Referrer-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy) может помочь оценить, происходит ли раскрытие учётных данных через заголовок Referrer.

## Связанный сценарий тестирования

- [Тестирование JWT](../06-Session_Management_Testing/10-Testing_JSON_Web_Tokens.md)

## Меры защиты

- При внедрении OAuth всегда учитывайте используемую технологию и то, где находится приложение: если на стороне сервера, то оно может избежать раскрытия секретов, а если на стороне клиента, то нет.
- Практически в любом случае используйте поток кодов авторизации с PKCE. Единственное исключение — потоки без участия пользователей.
- Для передачи секретов используйте параметры POST или значения заголовков.
- Если других возможностей нет (например, в устаревших приложениях, которые нельзя мигрировать), реализуйте дополнительные заголовки безопасности, например, `Referrer-Policy`.

## Инструменты

- [Burp Suite](https://portswigger.net/burp/releases)
- [EsPReSSO (расширение для Burp)](https://github.com/portswigger/espresso)
- [OWASP ZAP](https://www.zaproxy.org/)

## Ссылки

- [Аутентификация пользователей в OAuth 2.0](https://oauth.net/articles/authentication/)
- [Фреймворк авторизации OAuth 2.0](https://datatracker.ietf.org/doc/html/rfc6749)
- [Фреймворк авторизации OAuth 2.0: Использование токена на предъявителя](https://datatracker.ietf.org/doc/html/rfc6750)
- [Модель угроз OAuth 2.0 и соображения безопасности](https://datatracker.ietf.org/doc/html/rfc6819)
- [Рекомендации по безопасности OAuth 2.0](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics-20)
- [Поток кода авторизации с ключом подтверждения для обмена кодами (PKCE)](https://auth0.com/docs/authorization/flows/authorization-code-flow-with-proof-key-for-code-exchange-pkce)
