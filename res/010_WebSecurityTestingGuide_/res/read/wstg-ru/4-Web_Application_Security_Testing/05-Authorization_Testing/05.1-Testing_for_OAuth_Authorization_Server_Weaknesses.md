---

layout: col-document
title: WSTG - Latest
tags: WSTG

---

{% include breadcrumb.html %}
# Тестирование уязвимостей сервера авторизации OAuth

## Обзор

OAuth хранит учётные данные пользователей и их соответствующие права доступа на сервере авторизации (AS). AS играет решающую роль в потоке OAuth, поскольку он предоставляет клиентам доступ к ресурсам. Чтобы иметь возможность делать это безопасно, он должен правильно проверять параметры, которые являются частью потока OAuth.

Неспособность проверить параметры может привести к захвату учётных данных, несанкционированному доступу к ресурсам и повышению привилегий.

## Задачи тестирования

- Найти уязвимости в сервере авторизации.

## Как тестировать

Чтобы проверить наличие слабых мест в AS, вы должны:

1. Извлечь учётные данные, используемые для авторизации.
2. Предоставить себе доступ к произвольным ресурсам с помощью принудительного просмотра.
3. Обойти авторизацию.

### Тестирование на недостаточный контроль Redirect URI

Если `redirect_uri` должным образом не контролируется, может быть создана ссылка, содержащая URL, указывающий на сервер, контролируемый злоумышленником. Это может быть использовано для обмана AS с целью отправки кода авторизации злоумышленнику. В следующем примере при фальсификации `redirect_uri` используется `client.evil.com`:

```text
https://as.example.com/authorize?client_id=example-client&redirect_uri=http%3A%2F%client.evil.com%2F&state=example&response_mode=fragment&response_type=code&scope=openid&nonce=example
```

Если пользователь откроет эту ссылку в браузере, AS перенаправит его на вредоносный URL.

Злоумышленник может перехватить значение `code`, передаваемое в поддельном URL, а затем отправить его в конечную точку AS `/token`.

Следующий пример иллюстрирует как клиент `client.example.com` отправляет на `as.example.com` запрос на авторизацию, где `redirect_uri` `http%3A%2F%2Fclient.example.com%2F`передаётся в URL-кодировке:

```http
GET /authorize
    ?redirect_uri=http%3A%2F%2Fclient.example.com%2F
    &client_id=example-client
    &errorPath=%2Ferror
    &scope=openid%20profile%20email
    &response_type=code
    &response_mode=query
    &state=example
    &nonce=example
    &code_challenge=example
    &code_challenge_method=S256 HTTP/1.1
Host: as.example.com
```

AS отвечает перенаправлением, содержащим код авторизации. Его можно обменять на токен доступа в запросе токена. Как показано ниже, URL в заголовке `Location` — это URI, указанный в предыдущем параметре `redirect_uri`.

```http
HTTP/1.1 302 Found
Date: Mon, 18 Oct 2021 20:46:44 GMT
Content-Type: text/html; charset=utf-8
Content-Length: 340
Location: http://client.example.com/?code=example&state=example
```

Чтобы проверить, уязвим ли AS из-за недостаточного контроля `redirect_uri`, перехватите трафик с помощью HTTP-прокси, например, OWASP ZAP.

1. Запустите поток OAuth и приостановите его при запросе авторизации.
2. Измените значение `redirect_uri` и обратите внимание на ответ.
3. Изучите ответ и определите, принял ли AS произвольный параметр `redirect_uri`.

Если AS перенаправляет агент пользователя на указанный вами `redirect_uri`, AS должным образом не проверяет `redirect_uri`.

Кроме того, см. раздел `Распространённые пути обхода фильтра` в сценарии [Тестирование подделки запроса на стороне сервера](../07-Input_Validation_Testing/19-Testing_for_Server-Side_Request_Forgery.md), чтобы выявить распространённые обходные пути для контроля `redirect_uri`.

### Тестирование на инъекцию кода авторизации

В процессе обмена кодами в потоке кода авторизации AS выдаёт код клиенту, а затем в конечной точке  `/token` обменивает его на токены авторизации и обновления.

Проведите следующие тесты AS:

1. Отправьте действующий код для другого `client_id`.
2. Отправьте действующий код для другого Владельца ресурса (RO).
3. Отправьте действующий код для другого `redirect_uri`.
4. Повторно отправьте код более одного раза (воспроизведение кода).

#### Тестирование публичных клиентских приложений

Запрос, отправленный на конечную точку `/token`, содержит код авторизации. Он обменивается на токен. Перехватите этот запрос с помощью HTTP-прокси, например, OWASP ZAP, и повторно отправьте запрос с изменёнными значениями.

```http
POST /oauth/token HTTP/1.1
Host: as.example.com
[...]

{
    "errorPath":"/error",
    "client_id":"example-client",
    "code":"СЮДА_ВСТАВЬТЕ_КОД",
    "grant_type":"authorization_code",
    "redirect_uri":"http://client.example.com"
}
```

Если AS отвечает с `access_token`, код был успешно внедрён.

#### Тестирование конфиденциальных клиентских приложений

Поскольку поток OAuth для конфиденциальных клиентов дополнительно защищён секретом клиента, невозможно напрямую отправить код авторизации в конечную точку `/token`. Вместо этого внедрите код авторизации в клиент. Этот внедрённый код затем будет отправлен в запросе токена, выданном конфиденциальным клиентом вместе с секретом клиента.

Во-первых, перехватите код авторизации от AS:

1. Запустите поток кода авторизации с пользователем Alice. Сделайте паузу, когда получите код от AS.
2. Не отправляйте код клиенту, а запишите его и соответствующее ему state.

Затем введите код:

 1. Запустите поток кода авторизации с пользователем Mallory и вставьте в процесс перехваченный ранее код и значения state для пользователя Alice.
 2. Если атака будет успешной, у клиента будет `authorization_token`, который предоставляет доступ к ресурсам, принадлежащим пользователю Alice.

```http
GET /callback?code=INJECT_CODE_HERE&state=example HTTP/1.1
Host: client.example.com
[...]

```

### Тестирование атаки на отключение PKCE

При определённых обстоятельствах расширение PKCE может быть удалено из потока кода авторизации. Это потенциально может сделать публичных клиентов уязвимыми для атак, предотвращаемых PKCE.

Это может произойти, когда:

- AS не поддерживает PKCE.
- AS должным образом не контролирует PKCE.

Оба случая можно протестировать с помощью перехватывающего HTTP-прокси, например, OWASP ZAP. Проведите следующие тесты:

1. Отправьте запрос на авторизацию без параметров `code_challenge=sha256(xyz)` и `code_challenge_method`.
2. Отправить запрос на авторизацию с пустым значением параметра `code_challenge=sha256(xyz)`.
3. Отправить запрос на авторизацию с модифицированным `code_challenge=sha256(xyz)`.

В приведённом ниже примере показаны значения, которые необходимо изменить или исключить:

```http
GET /authorize
    ?redirect_uri=http%3A%2F%client.example.com
    &client_id=example-client
    &errorPath=%2Ferror
    &scope=openid%20profile%20email
    &response_type=code
    &response_mode=web_message
    &state=example-state
    &nonce=example-nonce
    &code_challenge=ИЗМЕНИТЕ_ИЛИ_ИСКЛЮЧИТЕ_ЕГО
    &code_challenge_method=ИЗМЕНИТЕ_ИЛИ_ИСКЛЮЧИТЕ_ЕГО
    &prompt=none HTTP/1.1
Host: as.example.com
[...]

```

AS должен проверять значение `code_verifier` при обмене токенами. Чтобы протестировать:

1. Отправьте запрос токена без `code_verifier`.
2. Отправьте запрос токена с пустым `code_verifier`.
3. Отправьте запрос токена с `code_verifier`, действующим для другого кода авторизации.

```http
POST /oauth/token HTTP/1.1
Host: as.example.com
[...]

{
"client_id":"example-client",
"code_verifier":"ИЗМЕНИТЕ_ИЛИ_ИСКЛЮЧИТЕ_ЕГО",
"code":"example",
"grant_type":"authorization_code",
"redirect_uri":"http://client.example.com"
}
```

### Тестирование подделки межсайтовых запросов на странице согласия

CSRF-атаки описаны в [CSRF](../06-Session_Management_Testing/05-Testing_for_Cross_Site_Request_Forgery.md). OAuth можно атаковать с помощью CSRF.

Чтобы предотвратить атаки CSRF на OAuth, используйте параметр `state` в качестве anti-CSRF-токена.

Другие меры также могут предотвратить  CSRF, например, PKCE. Значение `nonce` также может выступать в качестве anti-CSRF-токена.

Проверяйте каждый запрос, содержащий один из параметров защиты от CSRF, используемых OAuth, в соответствии с тестами, описанными в тестовых примерах [CSRF](../06-Session_Management_Testing/05-Testing_for_Cross_Site_Request_Forgery.md).

Страница согласия отображается пользователю, чтобы убедиться, что он даёт клиентскому приложению согласие на доступ к ресурсу от его имени. Атака на страницу согласия с помощью CSRF может предоставить доступ к ресурсу произвольному клиенту от имени пользователя. Этапы этого потока:

1. Клиентское приложение генерирует параметр `state` и отправляет его с запросом согласия.
2. Агент пользователя (например, браузер) отображает страницу согласия.
3. Владелец ресурса (RO) предоставляет доступ Клиенту.
4. Согласие отправляется в AS вместе с подтверждёнными областями (scope).

Используйте HTTP-прокси, например, OWASP ZAP, чтобы убедиться, проверяется ли параметр `state`.

```http
POST /u/consent?state=Tampered_State HTTP/1.1
Host: as.example.com
[...]

state=ИЗМЕНИТЕ_ИЛИ_ИСКЛЮЧИТЕ_ЕГО
&audience=https%3A%2F%2Fas.example.com%2Fuserinfo
&scope%5B%5D=profile
&scope%5B%5D=email
&action=accept
```

### Тестирование на перехват клика

Перехват клика (англ.: clickjacking) описывается в разделе [Тестирование на перехват клика](../11-Client-side_Testing/09-Testing_for_Clickjacking.md). Когда страница согласия подвержена кликджекингу, а злоумышленник владеет `client_id` (для публичных клиентов или `client_secret` для конфиденциальных клиентов), злоумышленник может подделать согласие пользователя и получить доступ к запрошенному ресурсу через мошеннический клиент.

#### Как тестировать

Чтобы эта атака была успешной, злоумышленнику необходимо загрузить страницу авторизации в iframe.

Для загрузки страницы авторизации в iframe можно использовать следующую HTML-страницу:

```html
<html>
    <head>
        <title>Тестовая страница для кликджекинга</title>
    </head>
    <body>
        <iframe src="http://as.example.com/auth/realms/example/login-actions/required-action?execution=OAUTH_GRANT&client_id=example-client" width="500" height="500"></iframe>
    </body>
</html>
```

В случае успешной загрузки сайт уязвим для перехвата клика.

См. [Тестирование на перехват клика](../11-Client-side_Testing/09-Testing_for_Clickjacking.md) с подробным описанием того, как может быть проведена такая атака.

### Тестирование срока действия токена

В OAuth два типа токенов: токен доступа и токен обновления. Срок действия токена доступа должен быть ограничен. Это означает, что он краткосрочен: разумный срок действия зависит от применения и может составлять от 5 до 15 минут.

Токен обновления должен быть действителен в течение более длительного периода. Это должен быть одноразовый токен, который заменяется каждый раз после использования.

#### Тестирование подтверждения срока действия токена доступа

Когда в качестве токена доступа используется web-токен JSON (JWT), его актуальность можно выяснить, декодировав JWT. Это описано в разделе [Тестирование JWT](../06-Session_Management_Testing/10-Testing_JSON_Web_Tokens.md). Бывает, что AS неправильно проверяет срок действия JWT.

Чтобы проверить срок действия токена доступа используйте HTTP-прокси, например, OWASP ZAP. Перехватите запрос к конечной точке, содержащей токен доступа. Поместите этот запрос в Repeater и подождите до обозначенного в сроке времени. Срок действия токена доступа должен составлять от 5 до 15 минут в зависимости от конфиденциальности ресурсов.

Подобные запросы могут выглядеть следующим образом. Токен также может быть передан другими способами, например, в cookie.

```http
GET /userinfo HTTP/1.1
Host: as.example.com
[...]
Authorization: Bearer eyJhbGciOiJkaXIiL[...]

```

Протестируйте срок действия, отправляя запросы по прошествии различных периодов времени, например, через 5, 10 и 30 минут.

Этот процесс можно оптимизировать, автоматизировав шаги и регистрируя ответы сервера. Когда получен ответ со статусом HTTP 403 (вместо HTTP 200), это может указывать на то, что токен доступа больше не действителен.

#### Протестируйте проверку срока действия токена обновления

Токены обновления имеют более длительный срок действия, чем токены доступа. Из-за этого они должны быть признаны недействительными после использования при обмене на очередной токен доступа.

Токены обновления выдаются в том же запросе токена, при котором клиенту выдаётся токен доступа.

Используйте HTTP-прокси, например, OWASP ZAP. Подготовьтесь к тестированию, выполнив следующие действия:

1. Извлеките действующий токен обновления.
2. Перехватите запрос, который используется для обмена токена обновления на новый токен доступа.
3. Отправьте захваченный запрос ретранслятору запросов (Repeater).

В следующем примере токен обновления отправляется в составе POST.

```http
POST /token HTTP/1.1
Host: as.example.com
Cookie: [...]
[...]

grant_type=refresh_token
&refresh_token=eyJhbGciOiJIUz[...]
&client_id=example-client

```

Проведите следующие тесты:

1. Отправьте токен обновления и определите, выдает ли AS токен доступа.
2. Повторите действия с тем же токеном обновления, чтобы оценить, как часто принимается один и тот же токен обновления.

Если в качестве токена обновления используется  JWT можно определить действительность токена обновления, декодировав JWT. Это описано в разделе [Тестирование JWT](../06-Session_Management_Testing/10-Testing_JSON_Web_Tokens.md). Токен обновления может быть действителен в течение более длительного периода времени, но должен иметь конечную дату истечения срока действия.

Можно обеспечить дополнительную защиту с помощью обнаружения угона токена. Если при обмене токенами токен обновления используется по истечении срока его действия, AS делает недействительными все токены обновления. Чтобы протестировать этот механизм:

1. Отправьте токен обновления и определите, выдаёт ли AS токен доступа.
2. Повторяйте шаги с тем же токеном обновления, пока он не станет недействительным.
3. Используйте токен обновления из последнего ответа.

Если все токены обновления, которые были выданы клиенту для этого владельца ресурса, признаны недействительными, у AS есть обнаружение угона токенов.

## Связанные сценарии тестирования

- [Тестирование подделки межсайтовых запросов (CSRF)](../06-Session_Management_Testing/05-Testing_for_Cross_Site_Request_Forgery.md)
- [Тестирование перенаправления URL на стороне клиента](../11-Client-side_Testing/04-Testing_for_Client-side_URL_Redirect.md)
- [Тестирование подделки запросов на стороне сервера (SSRF)](../07-Input_Validation_Testing/19-Testing_for_Server-Side_Request_Forgery.md)
- [Тестирование JWT](../06-Session_Management_Testing/10-Testing_JSON_Web_Tokens.md)
- [Тестирование перехвата клика](../11-Client-side_Testing/09-Testing_for_Clickjacking.md)
- [Тестирование Cross Origin Resource Sharing (CORS)](../11-Client-side_Testing/07-Testing_Cross_Origin_Resource_Sharing.md)

## Меры защиты

Большинство атак на сервер авторизации OAuth можно предотвратить, проверив наличие и содержание параметров во время обмена кодом авторизации и токенами.

Ограничьте временной интервал и разрешённое использование учётных данных, таких как код авторизации и токен обновления. Это может предотвратить некоторые типы атак, а также ограничивает использование таких учётных данных злоумышленником, если он ими завладеет.

Правильная конфигурация мер защиты, таких как CORS, anti-CSRF-токены и заголовки для защиты от перехвата клика, помогут предотвратить или ограничить воздействие атак.

- Всегда проверяйте наличие всех параметров и контролируйте их значения.
- Используйте расширение PKCE для надлежащей защиты кода авторизации при обмене токенами.
- Не допускайте отключения функций безопасности, таких как расширение PKCE.
- Ограничивайте срок действия учётных данных.
- Используйте учётные данные только один раз везде, где это возможно, например, для кода авторизации.
- Установите имеющиеся меры защиты, такие как CORS, токены защиты от CSRF и заголовки защиты от перехвата кликов.

## Инструменты

- [Burp Suite](https://portswigger.net/burp/releases)
- [EsPReSSO (расширение для Burp)](https://github.com/portswigger/espresso)
- [OWASP ZAP](https://www.zaproxy.org/)

## Ссылки

- [Аутентификация пользователей в OAuth 2.0](https://oauth.net/articles/authentication/)
- [Фреймворк авторизации OAuth 2.0](https://datatracker.ietf.org/doc/html/rfc6749)
- [Фреймворк авторизации OAuth 2.0: Использование токена на предъявителя](https://datatracker.ietf.org/doc/html/rfc6750)
- [Модель угроз OAuth 2.0 и соображения безопасности](https://datatracker.ietf.org/doc/html/rfc6819)
- [Рекомендации по безопасности OAuth 2.0](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics-20)
- [Поток кода авторизации с ключом подтверждения для обмена кодами (PKCE)](https://auth0.com/docs/authorization/flows/authorization-code-flow-with-proof-key-for-code-exchange-pkce)
