---

layout: col-document
title: WSTG - Latest
tags: WSTG

---

{% include breadcrumb.html %}
# Тестирование инъекций в строке форматирования

|ID          |
|------------|
|WSTG-INPV-13|

## Обзор

Строка форматирования — это последовательность символов, заканчивающаяся нулём (т.е. нуль-терминированная), которая также содержит спецификаторы преобразования, интерпретируемые или преобразуемые во время выполнения. Если код на стороне сервера [конкатенирует пользовательский ввод со строкой форматирования](https://www.netsparker.com/blog/web-security/string-concatenation-format-string-vulnerabilities/), злоумышленник может добавить дополнительные спецификаторы преобразования, чтобы вызвать ошибку во время выполнения, раскрытие информации или переполнение буфера.

Наихудший случай уязвимостей для строк форматирования возникает в языках, которые не проверяют аргументы, а также включают спецификатор `%n`, который пишет в память. Эти функции при их эксплуатации злоумышленником, изменяющим строку форматирования, могут привести к [раскрытию информации и выполнению кода](https://www.veracode.com/security/format-string):

- C и C++: [printf](https://en.cppreference.com/w/c/io/fprintf) и похожие (fprintf, sprintf, snprintf)
- Perl: [printf](https://perldoc.perl.org/functions/printf.html) и sprintf

Приведённые ниже функции форматирования строк не могут выполнять запись в память, но злоумышленники всё равно могут вызвать раскрытие информации, изменив строки форматирования на выходные значения, которые разработчики не собирались выводить:

- Python 2.6 и 2.7: [str.format](https://docs.python.org/2/library/string.html) и в Python 3 unicode [str.format](https://docs.python.org/3/library/stdtypes.html#str.format) может быть изменён путём инъекции строк, которые могут указывать на [другие переменные](https://lucumr.pocoo.org/2016/12/29/careful-with-str-format/) в памяти.

Следующие функции строк форматирования могут вызывать ошибки во время выполнения, если злоумышленник добавляет спецификаторы преобразования:

- Java: [String.format](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#format%28java.util.Locale%2Cjava.lang.String%2Cjava.lang.Object...%29) и [PrintStream.format](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/PrintStream.html#format%2528java.util.Locale%252Cjava.lang.String%252Cjava.lang.Object...%2529)
- PHP: [printf](https://www.php.net/manual/ru/function.printf.php)

Образец кода, вызывающий уязвимость строки форматирования, представляет собой вызов функции форматирования строки, которая содержит пользовательский ввод без нейтрализации. В следующем примере показано, как отладочная команда `printf` может сделать программу уязвимой:

Пример на Си:

```c
char *userName = /* ввод из поля, контролируемого пользователем */;

printf("DEBUG Current user: ");
// Уязвимый отладочный код
printf(userName);
```

Пример на Java:

```java
final String userName = /* ввод из поля, контролируемого пользователем */;

System.out.printf("DEBUG Current user: ");
// Уязвимый код:
System.out.printf(userName);
```

В этом конкретном примере, если злоумышленник установит для своего `userName` один или несколько спецификаторов преобразования, это приведет к нежелательному поведению. Пример на Си [выведет на экран содержимое памяти](https://www.defcon.org/images/defcon-18/dc-18-presentations/Haas/DEFCON-18-Haas-Adv-Format-String-Attacks.pdf) если `userName` содержит `%p%p%p%p%p`, и может повредить содержимое памяти, если в строке есть `%n`. В примере на Java `username`, содержащее любой спецификатор, который требует ввода (включая `%x` или `%s`), приведёт к сбою программы с сообщением `IllegalFormatException`. Хотя приведённые выше примеры подвержены другим уязвимостям, уязвимость строки форматирования может быть устранена с помощью аргументов команды printf: `printf("DEBUG Current user: %s", userName)`.

## Задача тестирования

- Оценить, не вызывает ли инъекция спецификаторов преобразования строк форматирования в контролируемые пользователем поля нежелательного поведения приложения.

## Как тестировать

Тесты включают анализ кода и инъекцию спецификаторов преобразования в качестве пользовательского ввода в тестируемое приложение.

### Статический анализ

Инструменты статического анализа могут находить уязвимости строк форматирования либо в коде, либо в бинарных файлах. Примеры инструментов включают:

- C и C++: [Flawfinder](https://dwheeler.com/flawfinder/)
- Java: правило FindSecurityBugs [FORMAT_STRING_MANIPULATION](https://find-sec-bugs.github.io/bugs.htm#FORMAT_STRING_MANIPULATION)
- PHP: String formatter Analyzer в [phpsa](https://github.com/ovr/phpsa/blob/master/docs/05_Analyzers.md#function_string_formater)

### Анализ кода вручную

Статический анализ кода может пропустить более тонкие случаи, включая строки форматирования, сгенерированные сложным кодом. Чтобы вручную искать уязвимости в кодовой базе, тестировщик может просмотреть все вызовы, которые принимают строку форматирования, и выполнить трассировку, чтобы убедиться, что недоверенный ввод не может её изменить.

### Инъекция спецификатора преобразования

Тестировщики могут проверить на уровне модульного или комплексного теста, передавая спецификаторы преобразования в любую строку ввода. Проведите [фаззинг](https://owasp.org/www-community/Fuzzing), используя все спецификаторы преобразования для всех языков, которые использует тестируемая система. См. страницу [OWASP Атака строки форматирования](https://owasp.org/www-community/attacks/Format_string_attack) с возможными входными данными. Если тест завершится неудачей, программа выйдет из строя или отобразит неожиданный результат. Если тест пройден, попытка передать спецификатор преобразования должна быть заблокирована, иначе строка должна пройти через систему без проблем, как и любой другой допустимый ввод.

В следующих подразделах в качестве примера будут использоваться URL вида:

`https://vulnerable_host/userinfo?username=x`

- `x` — контролируемое пользователем значение (для параметра `username`).

#### Ручная инъекция

Тестировщики могут провести ручное тестирование с помощью web-браузера или других инструментов отладки web-API. Перейдите к web-приложению или сайту, чтобы запрос содержал спецификаторы преобразования. Обратите внимание, что большинству спецификаторов преобразования требуется [экранирование](https://tools.ietf.org/html/rfc3986#section-2.1), если они передаются внутри URL, поскольку они содержат специальные символы, включая `%` и `{`. В тесте можно ввести строку спецификаторов `%s%s%s%n`, перейдя по следующему URL:

`https://vulnerable_host/userinfo?username=%25s%25s%25s%25n`

Если web-сайт уязвим, браузер или инструмент должны получить сообщение об ошибке, которое может включать тайм-аут или код статуса HTTP 500.

Код на Java возвращает ошибку

`java.util.MissingFormatArgumentException: Format specifier '%s'`

В зависимости от реализации языка Си процесс может завершиться сбоем из-за `Segmentation Fault`.

#### Инструментальный фаззинг

Инструменты для фаззинга, включая [wfuzz](https://github.com/xmendez/wfuzz), могут автоматизировать тесты инъекций. Для wfuzz начните с текстового файла (fuzz.txt в этом примере) с одним вводом на строку:

fuzz.txt:

```text
alice
%s%s%s%n
%p%p%p%p%p
{event.__init__.__globals__[CONFIG][SECRET_KEY]}
```

Файл `fuzz.txt ` содержит:

- Допустимые входные данные `alice` для проверки того, что приложение может обрабатывать обычный ввод.
- Две строки с Си-подобными спецификаторами преобразования.
- Один спецификатор преобразования Python для попытки чтения глобальных переменных.

Чтобы передать входной файл фаззинга в тестируемое web-приложение, воспользуйтесь следующей командой:

`wfuzz -c -z file,fuzz.txt,urlencode https://vulnerable_host/userinfo?username=FUZZ`

В приведённом выше вызове аргумент `urlencode` позволяет выполнить соответствующее экранирование строк, а `FUZZ` (заглавными буквами) указывает инструменту, куда вводить входные данные.

Пример вывода выглядит следующим образом:

```text
ID           Response   Lines    Word     Chars       Payload
===================================================================

000000002:   500        0 L      5 W      142 Ch      "%25s%25s%25s%25n"
000000003:   500        0 L      5 W      137 Ch      "%25p%25p%25p%25p%25p"
000000004:   200        0 L      1 W      48 Ch       "%7Bevent.__init__.__globals__%5BCONFIG%5D%5BSECRET_KEY%5D%7D"
000000001:   200        0 L      1 W      5 Ch        "alice"
```

Приведенный выше результат подтверждает уязвимость приложения к инъекции Си-подобных спецификаторов преобразования `%s` и `%p`.
