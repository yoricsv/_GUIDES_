---

layout: col-document
title: WSTG - Latest
tags: WSTG

---

{% include breadcrumb.html %}
# Тестирование HTTP Splitting/Smuggling

|ID          |
|------------|
|WSTG-INPV-15|

## Обзор

В этом разделе приведены примеры атак, которые используют специфические возможности протокола HTTP, либо используя уязвимости web-приложения, либо особенности того, как различные браузеры интерпретируют HTTP-сообщения.

В этом разделе будут проанализированы две различные атаки, нацеленные на определенные HTTP-заголовки:

- HTTP splitting
- HTTP smuggling

Первая атака эксплуатирует отсутствие нейтрализации ввода, что позволяет злоумышленнику вставлять символы CR и LF в заголовки ответа приложения и «расщеплять» (от англ.: split) этот ответ на два разных HTTP-сообщения. Цель атаки может варьироваться от отравления кэша до [межсайтового скриптинга](01-Testing_for_Reflected_Cross_Site_Scripting.md).

Во второй атаке злоумышленник использует тот факт, что некоторые специально составленные HTTP-сообщения могут быть проанализированы и интерпретированы по-разному в зависимости от агента, который их получает. HTTP smuggling (англ.: контрабанда) требует определённого уровня знаний о различных агентах, которые обрабатывают HTTP-сообщения (web-сервер, proxy-сервер, WAF (Web Application Firewall)), и поэтому будет включена только в раздел тестирования методом серого ящика.

## Задачи тестирования

- Оценить, уязвимо ли приложение к HTTP splitting, определив, какие из возможных атак сработают.
- Оценить, уязвима ли цепочка передачи для HTTP smuggling, и определить, какие из возможных атак сработают.

## Как тестировать

### Тестирование методом чёрного ящика

#### HTTP Splitting

Некоторые web-приложения используют часть введённой пользователем информации для формирования значений некоторых HTTP-заголовков ответов. Самый простой пример — перенаправления, в которых целевой URL зависит от некоторого введённого пользователем значения. Допустим, например, что пользователя просят выбрать, предпочитает ли он стандартный или расширенный web-интерфейс. Выбор передаётся как параметр, который будет использоваться в заголовке ответа для вызова перенаправления на соответствующую страницу.

Более конкретно, если параметру `interface` присвоено значение `advanced`, приложение ответит так:

```http
HTTP/1.1 302 Moved Temporarily
Date: Sun, 03 Dec 2005 16:22:19 GMT
Location: http://victim.com/main.jsp?interface=advanced
<snip>
```

При получении этого сообщения браузер перенаправит пользователя на страницу, указанную в заголовке Location. Однако, если приложение не фильтрует пользовательский ввод, можно будет вставить в параметр `interface` последовательность `%0d%0a`, которая представляет собой последовательность CRLF, используемую для разделения строк между собой. На этом этапе тестировщики смогут добиться ответа, который будет интерпретироваться как два разных ответа любым, кто его анализирует, например, web-кэшем, находящимся между нами и приложением. Злоумышленник может использовать это, чтобы отравить этот web-кэш, чтобы он предоставлял некорректный контент во все последующие запросы.

Допустим, в предыдущем примере тестировщик передаёт в качестве параметра `interface` следующие данные:

`advanced%0d%0aContent-Length:%200%0d%0a%0d%0aHTTP/1.1%20200%20OK%0d%0aContent-Type:%20text/html%0d%0aContent-Length:%2035%0d%0a%0d%0a<html>Sorry,%20System%20Down</html>`

Таким образом, результирующий ответ уязвимого приложения будет таким:

```http
HTTP/1.1 302 Moved Temporarily
Date: Sun, 03 Dec 2005 16:22:19 GMT
Location: http://victim.com/main.jsp?interface=advanced
Content-Length: 0

HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 35

<html>Sorry,%20System%20Down</html>
<other data>
```

Web-кэш увидит два разных ответа, поэтому, если злоумышленник отправит сразу после первого запроса второй `/index.html`, web-кэш сопоставит этот запрос со вторым ответом и кэширует его содержимое, поэтому что все последующие запросы, направленные на `victim.com/index.html`, проходящие через этот web-кэш, получат сообщение "System down". Таким образом, злоумышленник сможет дискредитировать (англ.: deface) сайт для всех пользователей, использующих этот web-кэш (или для всего Интернета, если web-кэш является обратным proxy-сервером для web-приложения).

В качестве альтернативы злоумышленник может передать этим пользователям фрагмент JavaScript, который вызовет атаку межсайтового скриптинга, например, для кражи cookie. Обратите внимание, что, хотя уязвимость находится в приложении, целью здесь являются его пользователи. Следовательно, чтобы найти эту уязвимость, необходимо найти все контролируемые пользователем входные данные, которые влияют на один или несколько заголовков в ответе, и убедиться, можно ли вставить в них последовательность CR + LF.

Наиболее вероятными кандидатами для этой атаки являются заголовки:

- `Location`
- `Set-Cookie`

Следует отметить, что успешная эксплуатация этой уязвимости в реальном сценарии может быть довольно сложной, поскольку необходимо учитывать несколько факторов:

1. Необходимо правильно установить заголовки в поддельном ответе, чтобы они кэшировались (например, заголовок `Last-Modified` с датой в будущем). Также может потребоваться удалить ранее кэшированные версии целевых страниц, предварительно отправив запрос с `Pragma: no-cache` в заголовках запроса.
2. Приложение, не фильтруя последовательность CR+LF, может фильтровать другие символы, необходимые для успешной атаки (например, `<` и `>`). В этом случае можно попробовать использовать другие кодировки (например, UTF-7).
3. Некоторые целевые объекты (например, на ASP) будут URL-кодировать части пути заголовка Location (например, `www.victim.com/redirect.asp`), что делает последовательность CRLF бесполезной. Однако им не удаётся закодировать параметры запроса (например, `?interface=advanced`), а это означает, что вопросительного знака впереди достаточно, чтобы обойти эту фильтрацию.

Для более подробного обсуждения этой атаки и другой информации о возможных сценариях и приложениях ознакомьтесь с документами, на которые даны ссылки в нижней части этого раздела.

### Тестирование методом серого ящика

#### HTTP Splitting

Успешной эксплуатации HTTP Splitting в значительной степени помогает знание некоторых деталей web-приложения и цели атаки. Например, разные целевые объекты могут использовать разные методы для определения того, где заканчивается первое HTTP-сообщение и начинается второе. Одни будут использовать границы сообщений, как в предыдущем примере. Другие будут предполагать, что разные сообщения передаются в разных пакетах. Третьи будут выделять для каждого сообщения определённое количество фрагментов заданной длины: в этом случае второе сообщение должно начинаться точно с начала фрагмента, что потребует подбора заполнения (англ.: padding) между двумя сообщениями. Это может вызвать проблемы при передаче уязвимого параметра в URL, поскольку очень длинный URL, скорее всего, будет обрезан или отфильтрован. Метод серого ящика может помочь злоумышленнику найти обходной путь: например, некоторые серверы приложений позволяют передавать запрос с использованием POST вместо GET.

#### HTTP Smuggling

Как упоминалось во введении, HTTP Smuggling использует различные способы, с помощью которых специально составленное HTTP-сообщение может быть проанализировано и интерпретировано различными агентами (браузер, web-кэш, WAF). Этот относительно новый вид атаки был впервые обнаружен Chaim Linhart, Amit Klein, Ronen Heled и Steve Orrin в 2005 г.  Существует несколько возможных применений, но мы проанализируем одно из самых впечатляющих: обход WAF. Обратитесь к оригинальному техническому руководству (ссылка внизу этой страницы) за более подробной информацией и другими сценариями.

##### Обход WAF

Есть несколько продуктов, позволяющих системному администратору обнаруживать и блокировать враждебные web-запросы в зависимости от известного вредоносного шаблона, встроенного в запрос. Например, рассмотрим печально известную старую [атаку обхода каталога Unicode на сервере IIS](https://attackerkb.com/topics/FQ2J87GsDl/cve-2000-0884), в которой злоумышленник мог взломать webroot, отправив запрос типа:

`http://target/scripts/..%c1%1c../winnt/system32/cmd.exe?/c+<исполняемая_команда>`

Конечно, довольно легко обнаружить и отфильтровать эту атаку по наличию в URL таких строк, как `..` и `cmd.exe`. Однако IIS 5.0 довольно требователен к запросам POST, размер тела которых составляет до 48 Кбайт, и обрезает всё, что выходит за эти рамки, если заголовок `Content-Type` отличается от `application/x-www-form-urlencoded`. Можно воспользоваться этим, создав очень большой запрос, структурированный следующим образом:

```http
POST /target.asp HTTP/1.1        <-- запрос №1
Host: target
Connection: Keep-Alive
Content-Length: 49225
<CRLF>
<49152 байта мусора>
```

```http
POST /target.asp HTTP/1.0        <-- запрос №2
Connection: Keep-Alive
Content-Length: 33
<CRLF>
```

```http
POST /target.asp HTTP/1.0        <-- запрос №3
xxxx: POST /scripts/..%c1%1c../winnt/system32/cmd.exe?/c+dir HTTP/1.0   <-- запрос №4
Connection: Keep-Alive
<CRLF>
```

Здесь происходит вот что: `запрос №1` состоит из 49223 байт, включая строки `запроса №2`. Следовательно, WAF (или любой другой агент, кроме IIS 5.0) увидит `запрос №1`, не увидит `запрос №2` (его данные будут лишь частью `№1`), увидит `запрос №3` и пропустит `запрос №4` (поскольку этот POST будет частью вымышленного заголовка `xxxx`).

А что происходит с IIS 5.0? Он перестанет парсить `запрос №1` сразу после 49152 байтов мусора (поскольку он достигнет предела 48 КБ = 49152 байта) и, следовательно, будет разбирать `запрос №2` как новый отдельный запрос. `Запрос №2` утверждает, что его содержимое составляет 33 байта, включая всё до `xxxx:`, из-за чего IIS пропускает `запрос №3` (интерпретируя его как часть `запроса №2`), но обнаруживает `запрос №4`, т.к. его POST начинается сразу после 33-го байта или `запроса №2`. Немного сложно, но дело в том, что URL атаки не будет обнаружен WAF (т.к. интерпретируется как тело предыдущего запроса), но будет правильно разобран (и выполнен) IIS.

Хотя в вышеупомянутом случае метод использует ошибку web-сервера, существуют и другие сценарии, в которых мы можем использовать различные способы, которыми разные HTTP-агенты анализируют сообщения, не соответствующие RFC 1005. Например, протокол HTTP допускает только один заголовок Content-Length, но не определяет, как обрабатывать сообщение, имеющее два экземпляра этого заголовка. Некоторые реализации будут использовать первый, в то время как другие предпочтут второй, расчищая путь для атак HTTP Smuggling. Другой пример — использование заголовка Content-Length в сообщении GET.

Обратите внимание, что при HTTP Smuggling *не* используются уязвимости в целевом web-приложении. Таким образом, может быть несколько сложно убедить клиента в том, что контрмеры следует искать в любом случае.

## Ссылки

### Технические руководства

- [Amit Klein, "Divide and Conquer: HTTP Response Splitting, Web Cache Poisoning Attacks, and Related Topics"](https://packetstormsecurity.com/files/32815/Divide-and-Conquer-HTTP-Response-Splitting-Whitepaper.html)
- [Amit Klein: "HTTP Message Splitting, Smuggling and Other Animals"](https://www.slideserve.com/alicia/http-message-splitting-smuggling-and-other-animals-powerpoint-ppt-presentation)
- [Amit Klein: "HTTP Request Smuggling - ERRATA (the IIS 48K buffer phenomenon)"](https://www.securityfocus.com/archive/1/411418)
- [Amit Klein: "HTTP Response Smuggling"](https://www.securityfocus.com/archive/1/425593)
- [Chaim Linhart, Amit Klein, Ronen Heled, Steve Orrin: "HTTP Request Smuggling"](https://www.cgisecurity.com/lib/http-request-smuggling.pdf)
- [HTTP Response Splitting: разделяй и властвуй](https://xakep.ru/2004/09/30/24084/)
- [HTTP REQUEST SMUGGLING (Часть 1)](https://www.securitylab.ru/analytics/216403.php)
- [HTTP REQUEST SMUGGLING (Часть 2)](https://www.securitylab.ru/analytics/216404.php)