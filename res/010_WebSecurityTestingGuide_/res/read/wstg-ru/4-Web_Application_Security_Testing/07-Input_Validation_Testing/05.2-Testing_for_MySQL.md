---

layout: col-document
title: WSTG - Latest
tags: WSTG

---

{% include breadcrumb.html %}
# Тестирование MySQL

## Обзор

Уязвимости [SQL инъекции](https://owasp.org/www-community/attacks/SQL_Injection) возникают всякий раз, когда при построении SQL-запроса входные данные используются без надлежащего ограничения или нейтрализации. Доступ к таким уязвимостям открывает динамический SQL (построение SQL-запросов путём конкатенации строк). SQL-инъекция позволяет злоумышленнику получить доступ к SQL-серверам и выполнять код SQL под привилегиями пользователя, подключенного к базе данных.

*Сервер MySQL* имеет несколько особенностей, поэтому некоторые эксплойты необходимо специально адаптировать под это приложение. Это тема данного раздела.

## Как тестировать

Когда уязвимость SQL-инъекции обнаруживается в приложении, поддерживаемом базой данных MySQL, существует ряд атак, которые можно провести в зависимости от версии MySQL и привилегий пользователя в СУБД.

MySQL поставляется в нескольких версиях, которые эксплуатируются по всему миру: `3.23.x`, `4.0.x`, `4.1.x` и `5.0.x` (примечание: на момент перевода также появились версии `5.1.x`, `5.5.x`, `5.6.x`, `5.7.x` и `8.0.x` из которых поддерживаются только `5.7.x` и `8.0.x`). В каждой версии есть набор функций, появившийся в ней.

- Начиная с версии 4.0: UNION
- Начиная с версии 4.1: подзапросы
- Начиная с версии 5.0: хранимые процедуры и функции, представление `INFORMATION_SCHEMA`
- Начиная с версии 5.0.2: триггеры и т.д.

Следует отметить, что для MySQL версий до 4.0.x могли применяться только логические или основанные на времени слепые инъекции, поскольку функциональность подзапросов и оператор `UNION` ещё не были реализованы.

С этого момента мы будем предполагать, что существует классическая уязвимость SQL-инъекции, которая может быть вызвана запросом, подобным тому, который описан в разделе [Тестирование SQL-инъекций](05-Testing_for_SQL_Injection.md).

`http://www.example.com/page.php?id=2`

### Проблема с одинарными кавычками

Прежде чем воспользоваться возможностями MySQL, необходимо принять во внимание, как выглядят строки в SQL-выражении, поскольку web-приложения часто избегают одинарных кавычек.

Экранирование кавычек в MySQL выглядит следующим образом:

`'Строка с \'кавычками\''`

Т.е. MySQL интерпретирует экранированные апострофы `\'` как обычные, а не метасимволы.

Таким образом, если приложению для работы нужно использовать строковые константы, следует различать два случая:

1. Web-приложение экранирует одинарные кавычки `'` => `\'`
2. Web-приложение не экранирует одинарные кавычки `'` => `'`

В MySQL существует стандартный способ обойти необходимость использования одинарных кавычек, имея строковую константу, которая должна быть объявлена без необходимости использования одинарных кавычек.

Предположим, мы хотим узнать значение поля с именем `password` с условиями, подобными следующим:

1. `password LIKE 'A%'`
2. ASCII-значения символов в формате hex:
    `password LIKE 0x4125`
3. Функция char():
    `password LIKE CHAR(65,37)`

### Несколько смешанных запросов

Коннекторы библиотек MySQL не поддерживают несколько запросов, разделённых символом `;`, поэтому нельзя объединить несколько неоднородных SQL-команд в одну SQL-инъекцию, как в Microsoft SQL Server.

Например, следующая инъекция приведет к ошибке:

`1 ; update tablename set code='javascript code' where 1 --`

### Сбор информации

#### Идентификация MySQL

Конечно, первое, что нужно знать, — является ли СУБД MySQL сервером базы данных. Сервер MySQL имеет функцию, используемую для того, чтобы другие СУБД могли игнорировать SQL-выражения на диалекте MySQL. Когда блок комментариев `'/**/'` содержит восклицательный знак `'/*!тут должен быть sql*/'`, он интерпретируется MySQL, но рассматривается как обычный блок комментариев другими СУБД, как описано в [Руководстве по MySQL](https://dev.mysql.com/doc/refman/8.0/en/comments.html).

Пример:

`1 /*! and 1=0 */`

> Если это MySQL, выражение внутри блока комментариев будет интерпретировано.

#### Версии

Узнать версию можно тремя способами:

1. С помощью глобальной переменной `@@version`
2. С помощью функции [VERSION()](https://dev.mysql.com/doc/refman/8.0/en/information-functions.html#function_version)
3. С помощью идентификации версии по комментариям `/*!40110 and 1=0*/`

что означает

```sql
if(version >= 4.1.10)
   add 'and 1=0' to the query.
```

Способы эквивалентны, так как результат один и тот же.

Классическая инъекция:

`1 AND 1=0 UNION SELECT @@version /*`

Косвенная инъекция:

`1 AND @@version like '4.0%'`

Ответ будет содержать что-то вроде

`5.0.22-log`

#### Имя пользователя

Есть два типа пользователей, на которые полагается MySQL Server.

1. [USER()](https://dev.mysql.com/doc/refman/8.0/en/information-functions.html#function_user): пользователь, подключенный к серверу MySQL.
2. [CURRENT_USER()](https://dev.mysql.com/doc/refman/8.0/en/information-functions.html#function_current-user): внутренний пользователь, который выполняет запрос.

Между 1 и 2 есть некоторая разница. Отличие заключается в том, что анонимный пользователь может подключаться (если разрешено) с любым именем, а внутренний пользователь MySQL — это пустое имя (''). Ещё одно отличие в том, что хранимая процедура или функция выполняются от имени пользователя-создателя, если они не объявлены где-либо ещё. Это можно узнать через `CURRENT_USER`.

Классическая инъекция:

`1 AND 1=0 UNION SELECT USER()`

Косвенная инъекция:

`1 AND USER() like 'root%'`

В ответе будет что-то типа:

`user@hostname`

#### Используемое имя базы данных

Есть стандартная функция `DATABASE()`

Классическая инъекция:

`1 AND 1=0 UNION SELECT DATABASE()`

Косвенная инъекция:

`1 AND DATABASE() like 'db%'`

> Ожидаемый результат — строка типа
>
> `dbname`

#### INFORMATION_SCHEMA

Начиная с версии MySQL 5.0 было создано представление с именем [INFORMATION_SCHEMA](https://dev.mysql.com/doc/refman/8.0/en/information-schema.html). Оно позволяет нам получить всю информацию о базах данных, таблицах и столбцах, а также о процедурах и функциях.

| Таблицы в INFORMATION_SCHEMA | ОПИСАНИЕ |
|------------------------------|-------------|
| SCHEMATA  | Все базы данных пользователя (как минимум) SELECT_priv |
| SCHEMA_PRIVILEGES  | Привилегии, которые пользователь имеет в каждой БД |
| TABLES  | Все таблицы пользователя (как минимум) SELECT_priv |
| TABLE_PRIVILEGES | Привилегии, которые пользователь имеет в каждой таблице |
| COLUMNS | Все столбцы, которые есть у пользователя (как минимум) SELECT_priv |
| COLUMN_PRIVILEGES | Привилегии, которыми обладает пользователь для каждого столбца |
| VIEWS | Все представления, которые есть у пользователя (как минимум) SELECT_priv |
| ROUTINES | Процедуры и функции (необходима EXECUTE_priv) |
| TRIGGERS | Триггеры (нужна INSERT_priv) |
| USER_PRIVILEGES | Привилегии, которыми обладает подключенный пользователь |

Всю эту информацию можно извлечь с помощью известных методов, описанных в разделе [Тестирование SQL-инъекций](05-Testing_for_SQL_Injection.md).

### Векторы атак

#### Запись в файл

Если подключенный пользователь имеет привилегии `FILE` и одинарные кавычки не экранированы, предложение `into outfile` можно использовать для экспорта результатов запроса в файл.

`Select * from table into outfile '/tmp/file'`

Примечание. Невозможно обойти одинарные кавычки, окружающие имя файла. Поэтому, если есть какая-то нейтрализация одинарных кавычек, например, экранирование `\'`, то не будет возможности использовать предложение `into outfile`.

Этот вид атаки может быть использован как внеполосный метод для получения информации о результатах запроса или для записи файла, который может быть выполнен внутри каталога web-сервера.

Пример:

```sql
`1 limit 1 into outfile '/var/www/root/test.jsp' FIELDS ENCLOSED BY '//'  LINES TERMINATED BY '\n<%здесь jsp код%>';`
```

> Результаты сохраняются в файле с привилегиями `rw-rw-rw`, принадлежащими пользователю и группе MySQL,
>
> где `/var/www/root/test.jsp` будет содержать:
>
> `//field values//`
> `<%здесь jsp код%>`

#### Чтение из файла

`load_file` — это встроенная функция, которая может читать файл, если это допускают разрешения файловой системы. Если подключенный пользователь имеет привилегии `FILE`, его можно использовать для получения содержимого файлов. Одинарные кавычки позволяют избежать нейтрализации с помощью ранее описанных методов.

`load_file('filename')`

> Весь файл будет доступен для экспорта с использованием стандартных методов.

### Классическая атака SQL-инъекции

При классической SQL-инъекции результаты могут отображаться непосредственно на странице как обычный вывод или как ошибка MySQL. Используя уже упомянутые атаки SQL-инъекций и уже описанные функции MySQL, прямая SQL-инъекция может быть легко выполнена на уровне, зависящем в первую очередь от версии MySQL, с которой сталкивается тестировщик.

Хорошая атака заключается в том, чтобы узнать результаты, заставив функцию/процедуру или сам сервер выдать ошибку. Список ошибок, выдаваемых MySQL и, в частности, его собственными функциями, можно найти в [Руководстве по MySQL](https://dev.mysql.com/doc/mysql-errors/8.0/en/server-error-reference.html).

### Внеполосная SQL-инъекция

Внеполосная инъекция может быть выполнена с помощью предложения [`into outfile`](#запись-в-файл).

### Слепая SQL-инъекция

Для проведения слепой SQL-инъекции существует набор полезных функций, стандартно предоставляемых сервером MySQL.

- Длина строки:
    - `LENGTH(str)`
- Извлечь подстроку из заданной строки:
    - `SUBSTRING(string, offset, #chars_returned)`
- Слепая инъекция по времени:
    - BENCHMARK и SLEEP `BENCHMARK(#ofcycles,action_to_be_performed)`
    Если слепая инъекция с логическими условиями не даёт результата, можно применять функцию benchmark для проведения атак с задержками.
    См. `SLEEP()` (MySQL > 5.0.x) в качестве альтернативы benchmark.

Полный список функций и операторов см. в [Руководстве по MySQL](https://dev.mysql.com/doc/refman/8.0/en/functions.html)

## Инструменты

- [Francois Larouche: Multiple DBMS SQL Injection tool](http://www.sqlpowerinjector.com/index.htm)
- [Reversing.org - sqlbftools](https://packetstormsecurity.com/files/43795/sqlbftools-1.2.tar.gz.html)
- [Bernardo Damele A. G.: sqlmap, automatic SQL injection tool](https://sqlmap.org/)
- [Muhaimin Dzulfakar: MySqloit, MySql Injection takeover tool](https://code.google.com/archive/p/mysqloit/)

## Ссылки

### Технические руководства

- [Chris Anley: "Hackproofing MySQL"](https://www.securitylab.ru/_Article_Images/2004/HackproofingMySQL.pdf)

### Исследования по теме

- [Zeelock: Blind Injection in MySQL Databases](https://seclists.org/bugtraq/2005/Feb/att-288/zk-blind.txt)
