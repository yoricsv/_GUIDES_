---

layout: col-document
title: WSTG - Latest
tags: WSTG

---

{% include breadcrumb.html %}
# Тестирование «загрязнения» параметров HTTP

|ID          |
|------------|
|WSTG-INPV-04|

## Обзор

«Загрязнение» параметров HTTP (англ.: HTTP Parameter Pollution, HPP) проверяет реакцию приложений на получение нескольких параметров HTTP с одинаковым именем, например, если параметр `username` включён в параметры GET или POST дважды.

Предоставление нескольких параметров HTTP с одинаковым именем может привести к тому, что приложение будет интерпретировать значения непредвиденным образом. Эксплуатируя эти эффекты, злоумышленник может обойти проверку входных данных, вызвать ошибки приложения или изменить значения внутренних переменных. Поскольку загрязнение параметров HTTP влияет на все составляющие web-технологий, существуют серверные и клиентские атаки.

Текущие стандарты HTTP не содержат указаний о том, как интерпретировать несколько входных параметров с одним и тем же именем. Например, [RFC 3986](https://www.ietf.org/rfc/rfc3986.txt) просто определяет термин *строка запроса* как серию пар поле-значение, а [RFC 2396](https://www.ietf.org/rfc/rfc2396.txt) определяет классы зарезервированных и незарегистрированных символов строки запроса. В отсутствие стандарта компоненты web-приложений обрабатывают этот пограничный случай различными способами (подробности см. в таблице ниже).

Само по себе это не обязательно указывает на уязвимость. Однако, если разработчик не знает о проблеме, наличие повторяющихся параметров может привести к аномальному поведению приложения, которое потенциально может быть использовано злоумышленником. Как часто бывает в сфере безопасности, необычное поведение обычно является источником уязвимостей, которые в данном случае могут привести к атакам с загрязнением параметров HTTP. Чтобы лучше представить этот класс уязвимостей и результаты HPP-атак, интересно проанализировать некоторые примеры из реальной жизни, которые были обнаружены в прошлом.

### Контроль входных данных и обход фильтров

В 2009 году, сразу после публикации первого исследования о «загрязнении» параметров HTTP, этот метод привлек внимание сообщества безопасности как возможный способ обхода WAF.

Один из этих недостатков, влияющий на *ModSecurity SQL Injection Core Rules*, представляет собой прекрасный пример несоответствия сопротивлений между приложением и фильтром. Фильтр ModSecurity правильно применит список запрещений для следующей строки: `select 1,2,3 from table`, тем самым блокируя обработку web-сервером URL из данного примера: `/index.aspx?page=select 1,2,3 from table`. Однако, через конкатенацию нескольких параметров HTTP, злоумышленник может заставить сервер приложений объединить строку уже после того, как фильтр ModSecurity принял входные данные. Например, URL `/index.aspx?page=select 1&page=2,3 from table` не вызовет срабатывания фильтра ModSecurity, однако на уровне приложения входные данные снова конкатенируются в полную вредоносную строку.

Ещё одна уязвимость HPP затрагивает *Apple Cups*, хорошо известную систему печати, используемую во многих системах UNIX. Эксплуатируя HPP, злоумышленник может легко вызвать уязвимость межсайтового скриптинга, со следующим URL: `http://127.0.0.1:631/admin/?kerberos=onmouseover=alert(1)&kerberos`. Контрольную точку валидации приложения можно обойти, добавив дополнительный аргумент `kerberos`, имеющий допустимую строку (например, пустую). Поскольку контрольная точка будет анализировать только второе вхождение, первый параметр `kerberos` не был нейтрализован как должен перед использованием для создания динамического HTML-контента. Успешная эксплуатация приведёт к выполнению кода JavaScript в контексте размещённого web-сайта.

### Обход аутентификации

Ещё более критичная уязвимость HPP была обнаружена в *Blogger*, популярной платформе для ведения блогов. Ошибка позволяла злоумышленникам стать владельцем блога жертвы, используя следующий HTTP-запрос (`https://www.blogger.com/add-authors.do`):

```html
POST /add-authors.do HTTP/1.1
[...]

security_token=attackertoken&blogID=attackerblogidvalue&blogID=victimblogidvalue&authorsList=goldshlager19test%40gmail.com(email злоумышленника)&ok=Invite
```

Недостаток заключался в механизме аутентификации, используемом web-приложением, поскольку проверка безопасности выполнялась для первого параметра `blogID`, тогда как в реальной операции использовалось второе вхождение.

### Ожидаемое поведение сервера приложений

В следующей таблице показано, как различные web-технологии ведут себя при наличии нескольких вхождений одного и того же HTTP-параметра.

Дано: URL и строка запроса: `http://example.com/?color=red&color=blue`.

  | Бэкенд / сервер web-приложений | Результат парсинга URL | Пример |
  |--------------------------------|----------------|--------|
  | ASP.NET / IIS | Все вхождения через запятую |  color=red,blue |
  | ASP / IIS     | Все вхождения через запятую | color=red,blue |
  | .NET Core 3.1 / Kestrel | Все вхождения через запятую | color=red,blue |
  | .NET 5 / Kestrel | Все вхождения через запятую | color=red,blue |
  | PHP / Apache  | Только последнее вхождение | color=blue |
  | PHP / Zeus | Только последнее вхождение | color=blue |
  | JSP, Servlet / Apache Tomcat | Только первое вхождение | color=red |
  | JSP, Servlet / Oracle Application Server 10g | Только первое вхождение | color=red |
  | JSP, Servlet / Jetty  | Только первое вхождение | color=red |
  | IBM Lotus Domino | Только последнее вхождение | color=blue |
  | IBM HTTP Server | Только первое вхождение | color=red |
  | node.js / express | Только первое вхождение | color=red |
  | mod_perl, libapreq2 / Apache | Только первое вхождение | color=red |
  | Perl CGI / Apache | Только первое вхождение | color=red |
  | mod_wsgi (Python) / Apache | Только первое вхождение | color=red |
  | Python / Zope | Все вхождения, тип данных List | color=['red','blue'] |

(Источник: [Appsec EU 2009 Carettoni & Paola](https://owasp.org/www-pdf-archive/AppsecEU09_CarettoniDiPaola_v0.8.pdf))

## Задачи тестирования

- Определить бэкенд и используемый метод парсинга.
- Оценить точки инъекции и попытаться обойти входные фильтры с помощью HPP.

## Как тестировать

К счастью, поскольку назначение HTTP-параметров обычно обрабатывается сервером web-приложений, а не самим кодом приложения, тестирование реакции на загрязнение параметров должно быть стандартным для всех страниц и действий. Однако, поскольку необходимы глубокие знания бизнес-логики, тестирование HPP требует ручной работы. Автоматические инструменты могут помочь лишь отчасти, поскольку они имеют тенденцию генерировать слишком много ложных срабатываний. Кроме того, HPP может проявляться в компонентах как на стороне клиента, так и на стороне сервера.

### HPP со стороны сервера

Чтобы проверить наличие уязвимостей HPP, найдите любую форму или действие, которые допускают ввода данных пользователем. Параметры строки запроса в HTTP-запросах GET легко настроить в панели навигации браузера. Если действие формы состоит в передаче данных через POST, потребуется перехватывающий прокси для изменения данных POST перед их отправкой на сервер. Определив конкретный входной параметр для тестирования, можно отредактировать данные GET или POST, перехватив запрос, или изменить строку запроса после загрузки страницы ответа. Чтобы проверить наличие уязвимостей HPP, просто добавьте тот же параметр к данным GET или POST, но присвойте ему другое значение.

Например: при тестировании параметра `search_string` в строке запроса URL будет содержаться имя и значение этого параметра:

```text
http://example.com/?search_string=kittens
```

Конкретный параметр может быть скрыт среди нескольких других параметров, но подход тот же; оставьте другие параметры на месте и добавьте дубликат:

```text
http://example.com/?mode=guest&search_string=kittens&num_results=100
```

Добавьте тот же параметр с другим значением:

```text
http://example.com/?mode=guest&search_string=kittens&num_results=100&search_string=puppies
```

и отправьте новый запрос.

Проанализируйте страницу ответа, чтобы определить, результат парсинга. В приведённом выше примере результаты поиска могут отображать `kittens`, `puppies`, сочетание из обоих (`kittens,puppies` или `kittens~puppies` или `['kittens','puppies']`), а могут выдавать пустой результат или страницу с ошибкой.

Такое поведение, независимо от того, используется ли первый, последний или сочетание из входных параметров с одинаковым именем, с большой вероятностью будет таким же во всём приложении. Означает ли это поведение по умолчанию потенциальную уязвимость или нет, зависит от конкретной проверки входных данных и фильтрации, специфичных для данного приложения. Как правило: если существующей проверки входных данных и других механизмов защиты достаточно для одиночных входных данных, и если сервер присваивает только первые или последние загрязненные параметры, то это не означает наличие уязвимости. Если дублирующиеся параметры конкатенируются, разные компоненты web-приложения используют разные вхождения, или при тестировании возникает ошибка, повышается вероятность эксплуатации загрязнения параметров для вызова уязвимостей в системе защиты.

Для более глубокого анализа потребуется три HTTP-запроса для каждого HTTP-параметра:

1. Отправьте HTTP-запрос, содержащий стандартное имя и значение параметра, и запишите HTTP-ответ. Например, `page?par1=val1`
2. Замените значение параметра на своё, отправьте и запишите HTTP-ответ. Например, `page?par1=HPP_TEST1`
3. Отправьте новый запрос, комбинируя шаги (1) и (2). Снова сохраните HTTP-ответ. Например, `page?par1=val1&par1=HPP_TEST1`
4. Сравните ответы, полученные на всех предыдущих шагах. Если ответ (3) отличается от (1) и ответ (3) также отличается от (2), существует несоответствие сопротивлений, которое в конечном итоге может быть проэксплуатировано для вызова уязвимостей HPP.

Создание полноценного эксплойта из уязвимости, связанной с загрязнением параметра, выходит за рамки этого текста. См. ссылки для примеров и подробностей.

### HPP со стороны клиента

Подобно серверному HPP, ручное тестирование является единственным надёжным методом аудита web-приложений с целью выявления уязвимостей, связанных с загрязнением параметров, влияющих на компоненты на стороне клиента. В то время как в варианте на стороне сервера злоумышленник использует уязвимое web-приложение для доступа к защищённым данным или для выполнения действий, которые либо не разрешены, либо не должны выполняться, атаки на стороне клиента направлены на взлом клиентских компонентов и технологий.

Чтобы проверить наличие уязвимостей HPP на стороне клиента, найдите любую форму или действие, которые допускают ввод данных пользователем и показывают результат этого ввода. В идеале это страница поиска, но окно входа в систему может не отображать пользователю недопустимое имя.

Как и в случае с HPP на стороне сервера, загрязняйте каждый HTTP-параметр с помощью `%26HPP_TEST` и найдите *url-decoded* вхождения полезной нагрузки, предоставленной пользователем:

- `&HPP_TEST`
- `&amp;HPP_TEST`
- и т.д.

В частности, обратите внимание на ответы, имеющие HPP-векторы в атрибутах `data`, `src`, `href` или в действиях формы. Опять же, означает ли это поведение по умолчанию потенциальную уязвимость или нет, зависит от конкретной проверки входных данных, фильтрации и бизнес-логики приложения. Кроме того, важно отметить, что эта уязвимость может также повлиять на параметры строки запроса, используемые в XMLHttpRequest (XHR), создание атрибутов во время выполнения и другие технологии подключаемых модулей (например, переменные flashvars в Adobe Flash).

## Инструменты

- [Пассивные/активные сканеры в OWASP ZAP](https://www.zaproxy.org)

## Ссылки

### Технические руководства

- [HTTP Parameter Pollution - Luca Carettoni, Stefano di Paola](https://owasp.org/www-pdf-archive/AppsecEU09_CarettoniDiPaola_v0.8.pdf)
- [Client-side HTTP Parameter Pollution Example (Yahoo! Classic Mail flaw) - Stefano di Paola](https://blog.mindedsecurity.com/2009/05/client-side-http-parameter-pollution.html)
- [How to Detect HTTP Parameter Pollution Attacks - Chrysostomos Daniel](https://www.acunetix.com/blog/whitepaper-http-parameter-pollution/)
- [CAPEC-460: HTTP Parameter Pollution (HPP) - Evgeny Lebanidze](https://capec.mitre.org/data/definitions/460.html)
- [Automated Discovery of Parameter Pollution Vulnerabilities in Web Applications - Marco Balduzzi, Carmen Torrano Gimenez, Davide Balzarotti, Engin Kirda](http://s3.eurecom.fr/docs/ndss11_hpp.pdf)
