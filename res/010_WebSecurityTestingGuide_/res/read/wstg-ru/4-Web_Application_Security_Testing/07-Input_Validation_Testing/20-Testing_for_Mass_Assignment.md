---

layout: col-document
title: WSTG - Latest
tags: WSTG

---

{% include breadcrumb.html %}
# Тестирование массового переназначения

|ID          |
|------------|
|WSTG-INPV-20|

## Обзор

Современные web-приложения очень часто основаны на фреймворках. Многие из этих фреймворков web-приложений позволяют автоматически привязывать вводимые пользователем данные (в виде параметров HTTP-запроса) к внутренним объектам. Это часто называют автопривязкой (англ.: autobinding).

Эта функция иногда может использоваться для доступа к полям, которые никогда не предназначались для изменения извне, что приводит к повышению привилегий, фальсификации данных, обходу механизмов защиты и др.

В этом и заключается уязвимость массового переназначения.

Примеры чувствительных свойств:

- **Свойства, связанные с разрешениями**: должны устанавливаться только привилегированными пользователями (например, `is_admin`, `role`, `approved`).
- **Свойства, зависящие от процесса**: должны устанавливаться только внутри, после завершения процесса (например, `balance`, `status`, `email_verified`)
- **Внутренние свойства**: должны устанавливаться только внутри приложением (например, `created_at`, `updated_at`)

## Задачи тестирования

- Найти запросы, которые изменяют объекты.
- Оценить, можно ли изменять поля, которые никогда не предназначались для изменения извне.

## Как тестировать

Ниже приведён классический пример, который может помочь проиллюстрировать проблему.

Пусть у нас будет web-приложение на Java с объектом `User` (модель):

```java
public class User {
   private String username;
   private String password;
   private String email;
   private boolean isAdmin;

   //Getters & Setters
}
```

Чтобы создать нового пользователя, приложение реализует следующее представление:

```html
<form action="/createUser" method="POST">
     <input name="username" type="text">
     <input name="password" type="text">
     <input name="email" text="text">
     <input type="submit" value="Create">
</form>
```

Контроллер, который обрабатывает запрос на создание (Spring обеспечивает автоматическую привязку к модели `User`):

```java
@RequestMapping(value = "/createUser", method = RequestMethod.POST)
public String createUser(User user) {
   userService.add(user);
   return "successPage";
}
```

При передаче формы браузер формирует следующий запрос:

```http
POST /createUser
[...]
username=bob&password=supersecretpassword&email=bob@domain.test
```

Однако из-за автопривязки злоумышленник может добавить параметр `isAdmin` к запросу, который контроллер автоматически привяжет к модели.

```http
POST /createUser
[...]
username=bob&password=supersecretpassword&email=bob@domain.test&isAdmin=true
```

Создаётся пользователь со свойством `isAdmin`, имеющим значение `true`, что даст ему права администратора в приложении.

### Тестирование методом чёрного ящика

#### Обнаружение обработчиков

Чтобы определить, какая часть приложения уязвима для массового переназначения, проанализируйте все его компоненты, которые принимают ввод от пользователя и потенциально могут быть сопоставлены с моделью. Сюда входят все HTTP-запросы (скорее всего, это GET, POST и PUT), которые позволяют создавать или изменять операции на серверной части.

Одним из самых простых индикаторов потенциальных массовых переназначений является наличие скобочного синтаксиса для имён входных параметров, например:

```html
<input name="user[name]" type="text">
```

При обнаружении таких индикаторов попробуйте добавить входные данные, относящиеся к несуществующему атрибуту (например, `user[несуществующийатрибут]`), и проанализируйте ответ/поведение.

Если в приложении не реализованы меры защиты (например, список разрешённых полей), скорее всего, оно ответит ошибкой (например, 500-й) из-за того, что оно не находит атрибут, связанный с объектом. Что ещё интереснее, эти ошибки иногда облегчают обнаружение имён атрибутов и типов данных значений, необходимых для эксплуатации уязвимости, без доступа к исходному коду.

#### Определение чувствительных полей

Поскольку при тестировании методом чёрного ящика тестировщик не имеет доступа к исходному коду, необходимо найти другие способы для сбора информации об атрибутах, связанных с объектами.
Проанализируйте ответы, полученные серверной частью, обращая внимание на:

- исходный код HTML-страницы;
- пользовательский код JavaScript;
- ответы API.

Например, очень часто можно использовать обработчики, которые возвращают сведения об объекте, чтобы собрать подсказки по связанным полям.
Возьмём, например, обработчик, который возвращает профиль пользователя (например, `GET /profile`). Он может включать дополнительные атрибуты, связанные с пользователем (особенно интересно в этом примере выглядит атрибут `isAdmin`).

```json
{"_id":12345,"username":"bob","age":38,"email":"bob@domain.test","isAdmin":false}
```

Затем попробуйте использовать обработчики, которые позволяют изменять или создавать пользователей, добавляя атрибут `isAdmin`, установленный в `true`.

Другой подход заключается в использовании списков слов, чтобы попытаться перебрать все потенциальные атрибуты. Этот перебор можно автоматизировать (например, с помощью wfuzz, Burp Intruder, ZAP fuzzer и т.д.). Для определения потенциально чувствительных атрибутов может быть полезен [список слов](https://github.com/sqlmapproject/sqlmap/blob/master/data/txt/common-columns.txt), который включает в себя инструмент sqlmap.
Небольшой пример списка распространённых интересных имён атрибутов:

- `is_admin`
- `is_administrator`
- `isAdmin`
- `isAdministrator`
- `admin`
- `administrator`
- `role`

Если доступно несколько ролей, попробуйте сравнить запросы, сделанные пользователями с разными уровнями полномочий (обратите особое внимание на привилегированные роли). Например, если в запросы, сделанные пользователем с правами администратора, входят дополнительные параметры, попробуйте эти параметры от имени пользователя с низким уровнем привилегий/анонимного пользователя.

#### Оценка влияния

Влияние массового переназначения параметров может быть разным в зависимости от контекста, поэтому для каждого тестового ввода, предпринятого на предыдущем этапе, проанализируйте результат и определите, представляет ли он уязвимость, которая оказывает реальное влияние на безопасность web-приложения.
Например, изменение `id` объекта может привести к отказу в обслуживании приложения или эскалации привилегий. Другой пример связан с возможностью изменения роли/статуса пользователя (например, `role` или `isAdmin`), что приводит к эскалации привилегий.

### Тестирование методом серого ящика

Если анализ проводится методом тестирования серого ящика, можно следовать той же методологии для подтверждения наличия проблемы. Однако более глубокие знания о приложении позволяют легче идентифицировать фреймворки и обработчики, подверженные уязвимости массового переназначения.
В частности, если доступен исходный код, поиск входных векторов становится более простым и точным. В процессе анализа исходного кода используйте простые инструменты (например, команду grep) для поиска распространённых шаблонов в коде приложения.
Доступ к схеме БД или к исходному коду также позволяет легко идентифицировать чувствительные поля.

#### Java

Spring MVC позволяет автоматически привязывать пользовательский ввод к объекту. Определите контроллеры, которые обрабатывают запросы на изменение состояния (например, найдите вхождения `@RequestMapping`), а затем проверьте, установлены ли элементы управления (как на контроллере, так и на задействованных моделях). Ограничения на использование массового переназначения могут быть, например, в виде:

- список полей, подлежащих привязке с помощью метода `setAllowedFields` класса `DataBinder` (например, `binder.setAllowedFields(["username","password","email"])`)
- список полей, не подлежащих привязке, с помощью метода `setDisallowedFields` класса `DataBinder` (например,`binder.setDisallowedFields(["isAdmin"])`)

Также желательно обратить внимание на использование аннотации `@ModelAttribute`, которая позволяет указать другое имя/ключ.

#### PHP

Laravel Eloquent ORM предоставляет метод `create`, который позволяет автоматически назначать атрибуты. Однако последние версии Eloquent ORM обеспечивают защиту по умолчанию от уязвимостей массового переназначения, требующих явного указания разрешённых атрибутов, которые могут быть присвоены автоматически через массив `$fillable`, или атрибутов, которые должны быть защищены (без привязки) через массив `$guarded`. Следовательно, анализируя модели (классы, расширяющие класс `Model`), можно определить, какие атрибуты разрешены или запрещены, и, следовательно, указать на потенциальные уязвимости.

#### .NET

Привязка модели в ASP.NET автоматически привязывает пользовательский ввод к свойствам объекта. Это также работает со сложными типами и автоматически преобразует входные данные в свойства, если имена свойств совпадают со входными данными.
Найдите контроллеры, и проверьте, установлены ли элементы управления (как внутри контроллера, так и в задействованных моделях). Ограничения на эксплуатацию массового переназначения могут быть, например, в виде:

- поля, объявленные как `ReadOnly`
- списка полей, которые можно привязать с помощью атрибута `Bind` (например, `[Bind(Include = "FirstName, LastName")] Student std`), через `includeProperties` (например, `includeProperties: new[] { "FirstName, LastName" }`) или посредством `TryUpdateModel`;
- список полей, не подлежащих привязке с помощью атрибута `Bind` (например, `[Bind(Exclude = "Status")] Student std`) или через `excludeProperties` (например, `excludeProperties: new[] { "Status" }`).

## Меры защиты

Используйте встроенные функции, предоставляемые фреймворками, для определения привязываемых (англ.: bindable) и непривязываемых (англ.: non-bindable) полей. Предпочтителен подход, основанный на разрешённых полях (с возможностью привязки), в котором явно определяются только те свойства, которые могут обновляться пользователем.
Архитектурный подход для предотвращения этой проблемы заключается в использовании шаблона *Data Transfer Object* (DTO) во избежание прямой привязки. DTO должен включать только те поля, которые предназначены для редактирования пользователем.

## Ссылки

- [OWASP: API Security](https://github.com/OWASP/API-Security/blob/master/2019/en/src/0xa6-mass-assignment.md) ([перевод](https://habr.com/ru/company/owasp/blog/547174/))
- [OWASP: Cheat Sheet Series](https://cheatsheetseries.owasp.org/cheatsheets/Mass_Assignment_Cheat_Sheet.html)
- [CWE-915: Improperly Controlled Modification of Dynamically-Determined Object Attributes](https://cwe.mitre.org/data/definitions/915.html)
