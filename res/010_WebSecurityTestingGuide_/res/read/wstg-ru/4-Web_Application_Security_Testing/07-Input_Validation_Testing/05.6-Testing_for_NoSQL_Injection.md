---

layout: col-document
title: WSTG - Latest
tags: WSTG

---

{% include breadcrumb.html %}
# Тестирование NoSQL-инъекций

## Обзор

Базы данных NoSQL обеспечивают более слабые ограничения по согласованности данных, чем традиционные базы данных SQL. Требуя меньше реляционных ограничений и проверок на согласованность, базы данных NoSQL часто дают преимущества в производительности и масштабировании. Тем не менее, они по-прежнему потенциально уязвимы для атак инъекции, несмотря на то, что они не используют традиционный синтаксис SQL. Поскольку атаки инъекции NoSQL могут выполняться на [процедурном языке](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%86%D0%B5%D0%B4%D1%83%D1%80%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5), а не на [декларативном языке SQL](https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D0%BA%D0%BB%D0%B0%D1%80%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5), потенциальные последствия больше, чем при традиционном внедрении SQL.

Вызовы базы данных NoSQL пишутся на языке программирования приложения, клиентского API или форматируются в соответствии с принятым соглашением (например, `XML`, `JSON`, `LINQ` и т.д.). Меры контроля и нейтрализации приложений могут не сработать в ответ на вредоносный ввод, нацеленный на эти спецификации. Например, фильтрация распространённых специальных символов HTML, таких как `< > & ;`, не предотвратит атаки на JSON API, где специальные символы включают `/ { } :`.

В настоящее время известно более 200 [баз данных NoSQL](http://nosql-database.org), предоставляющих API на различных языках и моделях отношений. Каждый из них предлагает различные возможности и ограничения. Поскольку между ними нет общего языка, пример кода инъекции не будет применим ко всем базам данных NoSQL. По этой причине прежде, чем разрабатывать тесты с NoSQL-инъекциями, необходимо ознакомиться с синтаксисом, моделью данных и базовым языком программирования.

Атаки с использованием NoSQL-инъекций могут выполняться не в тех областях приложения, где обычные SQL-инъекции. Там, где SQL-инъекция будет выполняться на сервере базы данных, варианты NoSQL могут выполняться на уровне приложения или на уровне базы данных, в зависимости от используемого NoSQL API и модели данных. NoSQL-инъекции обычно выполняются, когда строка атаки парсится, оценивается или конкатенируется в вызов API NoSQL.

Кроме того, атаки по времени могут быть связаны с отсутствием контроля параллелизма в базе данных NoSQL. Они не охватываются тестами на инъекции. На момент написания MongoDB была наиболее широко используемой базой данных NoSQL, поэтому во всех примерах будут использоваться API MongoDB.

## Как тестировать

### Тестирование уязвимостей NoSQL-инъекций в MongoDB

API MongoDB ожидает вызовы BSON (Binary JSON) и включает безопасный инструмент сборки BSON-запросов. Однако, согласно документации MongoDB, несериализованные JSON и [JavaScript-выражения](https://docs.mongodb.org/manual/faq/developers/#javascript) разрешены в нескольких альтернативных параметрах запроса. Наиболее часто используемый вызов API, допускающий произвольный ввод JavaScript, — это оператор `$where`.

Оператор MongoDB `$where` обычно используется в качестве простого фильтра или проверки, как и в SQL.

`db.myCollection.find( { $where: "this.credits`` ``==`` ``this.debits" } );`

При желании также оценивается JavaScript для записи более сложных условий.

`db.myCollection.find( { $where: function() { return obj.credits - obj.debits < 0; } } );`

### Пример 1

Если бы злоумышленник смог манипулировать данными, передающимися в оператор `$where`, он мог бы включить произвольный JavaScript в состав запроса MongoDB. Пример уязвимости показан в следующем коде, если пользовательский ввод передаётся непосредственно в запрос MongoDB без нейтрализации.

`db.myCollection.find( { active: true, $where: function() { return obj.credits - obj.debits < $userInput; } } );;`

Как и при тестировании других типов инъекций, чтобы продемонстрировать проблему не обязательно полностью эксплуатировать уязвимость. Вводя специальные символы, соответствующие целевому языку API, и наблюдая за результатами, можно определить, правильно ли приложение обработало входные данные. Например, в MongoDB, если строка, содержащая любой из следующих специальных символов, передаётся без нейтрализации, то вызовет ошибку базы данных.

`' " \ ; { }`

При обычной SQL-инъекции аналогичная уязвимость позволяет злоумышленнику выполнять произвольные SQL-команды, раскрывая данные или манипулируя ими по своему усмотрению. Однако, поскольку JavaScript является полнофункциональным языком, он позволяет злоумышленнику не только манипулировать данными, но и запускать произвольный код. Например, вместо того, чтобы просто вызвать ошибку при тестировании, в настоящем эксплойте будут использоваться специальные символы для создания корректного JavaScript.

Данная строка `0;var date=new Date(); do{curDate = new Date();}while(curDate-date<10000)`, вставленная в `$userInput` в примере кода выше приведёт к тому, что весь экземпляр MongoDB будет выполняться при 100% загрузке процессора в течение 10 секунд.

`function() { return obj.credits - obj.debits < 0;var date=new Date(); do{curDate = new Date();}while(curDate-date<10000); }`

### Пример 2

Даже если входные данные, используемые в запросах, полностью нейтрализованы или параметризованы, есть альтернативный путь, по которому можно запустить NoSQL-инъекцию. Многие экземпляры NoSQL имеют свои собственные зарезервированные имена переменных, не зависящие от языка программирования приложения.

Например, в MongoDB синтаксис `$where` сам по себе является зарезервированным оператором запроса. Он должен быть передан в запрос точно так, как показано; любое изменение приведёт к ошибке базы данных. Однако, поскольку `$where` также является допустимым именем переменной в PHP, злоумышленник может вставить код в запрос, создав переменную PHP с именем `$where`. Документация PHP MongoDB явно предупреждает об этом разработчиков:

> Убедитесь, что для всех специальных операторов запроса (начинающихся с `$`) вы используете одинарные кавычки, чтобы PHP не пытался заменить `$exists` значением переменной `$exists`.

Даже если запрос не зависит от пользовательского ввода, как в следующем примере, злоумышленник может проэксплуатировать MongoDB, заменив оператор вредоносными данными.

`db.myCollection.find( { $where: function() { return obj.credits - obj.debits < 0; } } );`

Одним из способов потенциального присвоения данных переменным PHP является [загрязнение параметров HTTP](04-Testing_for_HTTP_Parameter_Pollution.md). Создав переменную с именем `$where` через загрязнение параметра, можно вызвать ошибку MongoDB, указывающую на то, что запрос больше не является допустимым. Любого значения `$where`, отличного от самой строки `$where`, должно быть достаточно, чтобы продемонстрировать уязвимость. Злоумышленник мог бы разработать полноценный эксплойт, вставив:

`$where: function() { //далее произвольный JavaScript }`

## Ссылки

### Полезные нагрузки для инъекций

- [Injection payload wordlist with examples of NoSQL Injection for MongoDB](https://github.com/cr0hn/nosqlinjection_wordlists)

### Технические руководства

- [Bryan Sullivan from Adobe: "NoSQL, But Even Less Security"](https://repository.root-me.org/Exploitation%20-%20Web/EN%20-%20NoSQL%20But%20Even%20Less%20Security.pdf)
- [Erlend from Bekk Consulting: "[Security] NOSQL-injection"](https://erlend.oftedal.no/blog/?blogid=110)
- [Felipe Aragon from Syhunt: "NoSQL/SSJS Injection"](http://www.syhunt.com/en/?n=Articles.NoSQLInjection)
- [MongoDB Documentation: "How does MongoDB address SQL or Query injection?"](https://docs.mongodb.org/manual/faq/developers/#how-does-mongodb-address-sql-or-query-injection)
- [PHP Documentation: "MongoDB Driver Classes"](https://www.php.net/manual/en/book.mongodb.php)
- [Hacking NodeJS and MongoDB](https://blog.websecurify.com/2014/08/hacking-nodejs-and-mongodb.html)
- [Attacking NodeJS and MongoDB](https://blog.websecurify.com/2014/08/attacks-nodejs-and-mongodb-part-to.html)
