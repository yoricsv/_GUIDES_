---

layout: col-document
title: WSTG - Latest
tags: WSTG

---

{% include breadcrumb.html %}
# Тестирование MS Access

## Обзор

Как сказано в общем описании [SQL-инъекций](https://owasp.org/www-community/attacks/SQL_Injection), подобные уязвимости возникают всякий раз, когда введённые пользователем данные используются при составлении SQL-запроса без надлежащего ограничения или нейтрализации. Этот класс уязвимостей позволяет злоумышленнику выполнить код SQL под привилегиями пользователя, подключенного к базе данных. В этом разделе будут обсуждаться соответствующие методы SQL-инъекций, использующие определённые функции [Microsoft Access](https://ru.wikipedia.org/wiki/Microsoft_Access).

## Как тестировать

### Идентификация MS Access

Идентификация используемой технологии базы данных при тестировании приложения на базе SQL — первый шаг к правильной оценке потенциальных уязвимостей.  Распространённый подход включает инъекции стандартных шаблонов атак SQL-инъекций (например, одинарная кавычка, двойная кавычка, ...) для вызова исключений базы данных. Предполагая, что приложение не обрабатывает исключения с нестандартными страницами, можно идентифицировать СУБД, наблюдая за сообщениями об ошибках.

В зависимости от конкретной используемой web-технологии приложения, управляемые MS Access, будут выдавать одну из следующих ошибок:

`Fatal error: Uncaught exception 'com_exception' with message Source: Microsoft JET Database Engine`

или

`Microsoft JET Database Engine error '80040e14'`

или

`Microsoft Office Access Database Engine`

Во всех этих случаях у нас есть подтверждение того, что мы тестируем приложение с использованием базы данных MS Access.

### Базовое тестирование

К сожалению, MS Access не поддерживает типичные операторы, которые традиционно используются при тестировании SQL-инъекций, в том числе:

- нет символов комментария
- нет вложенных запросов
- нет оператора LIMIT
- нет операторов типа SLEEP или BENCHMARK
- и т.д.

Тем не менее, эти функции можно эмулировать, комбинируя несколько операторов или используя альтернативные методы. Как уже упоминалось, невозможно применить трюк со вставкой символов `/*`, `--` или `#` для обрезания запроса. Однако, к счастью, мы можем обойти это ограничение, вставив символ `null`. Нулевой байт `%00` в SQL-запросе приводит к тому, что MS Access игнорирует все оставшиеся символы. Это можно объяснить, если знать, что все строки во внутреннем представлении базы данных заканчиваются NULL. Стоит отметить, что символ `null` иногда может вызывать проблемы, поскольку он может обрезать строки на уровне web-сервера. Однако в таких ситуациях мы можем использовать другой символ: `0x16` (`%16` в формате кодировки URL).

Рассматривая следующий запрос:

`SELECT [username],[password] FROM users WHERE [username]='$myUsername' AND [password]='$myPassword'`

Мы можем обрезать запрос с помощью следующих двух URL:

- `http://www.example.com/page.asp?user=admin'%00&pass=foo`
- `http://www.example.com/page.app?user=admin'%16&pass=foo`

Оператор `LIMIT` не реализован в MS Access, однако можно ограничить количество выводимых результатов, используя вместо этого операторы `TOP` или `LAST`.

`http://www.example.com/page.app?id=2'+UNION+SELECT+TOP+3+name+FROM+appsTable%00`

Комбинируя оба оператора, можно выбрать требуемые результаты. Конкатенация строк делается при помощи символов `& (%26)` и `+ (%2b)`.

Существует также множество других функций, которые можно использовать при тестировании SQL-инъекций, включая, помимо прочих:

- ASC: код ASCII символа, переданного на вход
- CHR: символ ASCII кода, переданного на вход
- LEN: длина строки, переданной в качестве параметра
- IIF: выражение IF, например, `IIF(1=1, 'a', 'b')` выдаёт `a`
- MID: извлечение подстроки, например, `mid('abc',1,1)` выдаёт `a`
- TOP: максимальное количество результатов с начала выборки, которые должен выдавать запрос. Например `TOP 1` выдаёт только 1 строку.
- LAST: последняя строка из выборки. Например, `SELECT last(*) FROM users` выдаёт только последнюю строку из результата.

Некоторые из этих операторов необходимы для слепых SQL-инъекций. Полный набор операторов можно найти в справочниках.

#### Определение атрибутов

Чтобы узнать про столбец таблицы базы данных, можно использовать распространённый метод, основанный на ошибках. Короче говоря, мы можем получить имя атрибута, проанализировав сообщения об ошибках и повторив запрос с разными селекторами. Например, предполагая, что мы знаем о существовании столбца, мы также можем получить имя остальных атрибутов с помощью запроса:

`' GROUP BY Id%00`

В полученном сообщении об ошибке можно увидеть название следующего столбца. На этом этапе мы можем повторять метод до тех пор, пока не получим имя всех атрибутов. Если мы не знаем имя первого атрибута, мы всё равно можем вставить фиктивное имя столбца и получить имя первого атрибута в сообщении об ошибке.

#### Получение схемы базы данных

В MS Access по умолчанию существуют различные системные таблицы, которые потенциально можно использовать для получения наименований таблиц и столбцов. К сожалению, в конфигурации по умолчанию последних выпусков MS Access эти таблицы недоступны. Тем не менее всегда стоит попробовать:

- MSysObjects
- MSysACEs
- MSysAccessXML

Например, если существует union-уязвимость SQL-инъекций, можно использовать запрос:

`' UNION SELECT Name FROM MSysObjects WHERE Type = 1%00`

Кроме того, можно определить схему базы данных, используя стандартный список слов (например, [FuzzDb](https://github.com/fuzzdb-project/fuzzdb)).

В некоторых случаях разработчики или системные администраторы не понимают, что размещение файла `.mdb` каталог webroot приложения может позволить загрузить базу данных целиком. Имена файлов базы данных можно получить с помощью следующего запроса:

`http://www.example.com/page.app?id=1'+UNION+SELECT+1+FROM+name.table%00`

где `name` — имя файла `.mdb`, а `table` — допустимая таблица базы данных. В случае баз данных, защищённых паролем, для взлома пароля можно использовать разные утилиты. См. раздел Ссылки.

### Тестирование слепых SQL-инъекций

Уязвимости [слепых SQL-инъекций](https://owasp.org/www-community/attacks/Blind_SQL_Injection) никогда не были легко эксплуатируемыми SQL-инъекциями при тестировании реальных приложений. В случае последних версий MS Access также невозможно выполнять команды оболочки или читать/записывать произвольные файлы.

В случае слепых SQL-инъекций злоумышленник может определить результат запроса только путем оценки разницы во времени или ответов приложения. Предполагается, что читатель уже знаком с теорией, лежащей в основе слепых атак SQL-инъекций, поскольку оставшаяся часть этого раздела будет посвящена конкретным деталям MS Access.

Используется следующий пример:

`http://www.example.com/index.php?myId=[sql]`

где параметр ID используется в следующем запросе:

`SELECT * FROM orders WHERE [id]=$myId`

Давайте рассмотрим параметр `myId`, уязвимый для слепой SQL-инъекции. Как злоумышленник, мы хотим извлечь содержимое столбца `username` в таблице `users`, предполагая, что мы уже раскрыли схему базы данных.

Типичным запросом, которым можно определить первый символ поля `username` в 10-й строке, будет:

`http://www.example.com/index.php?id=IIF((select%20MID(LAST(username),1,1)%20from%20(select%20TOP%2010%20username%20from%20users)='a',0,'no')`

Если первым символом является `a`, запрос выдаст `0`, в противном случае строку `no`.

Используя комбинацию функций `IFF, MID, LAST` и `TOP`, можно извлечь первый символ имени пользователя в выбранной строке. Поскольку внутренний запрос возвращает набор записей, а не одну, использовать его напрямую невозможно. К счастью, мы можем сочетать несколько функций для извлечения определённой строки.

Предположим, что мы хотим получить имя пользователя из 10-й строки. Во-первых, мы можем использовать функцию TOP для выбора первых десяти строк, используя следующий запрос:

`SELECT TOP 10 username FROM users`

Затем, используя это подмножество, мы можем извлечь последнюю строку с помощью функции LAST. Когда у нас есть только одна строка и это именно та строка, которая содержит нашу, мы можем использовать функции IFF, MID и LAST, чтобы вывести фактическое значение имени пользователя. В нашем примере мы используем IFF для выдачи числа или строки. Используя этот трюк, мы можем узнать правду, наблюдая за ответами об ошибках приложения. Поскольку `id` является числовым, сравнение со строкой приводит к ошибке SQL, которая потенциально может быть раскрыта в `500 Internal Server Error pages`. В противном случае, скорее всего, будет выдана стандартная страница `200 OK`.

Например, у нас может быть следующий запрос:

`http://www.example.com/index.php?id='%20AND%201=0%20OR%20'a'=IIF((select%20MID(LAST(username),1,1)%20from%20(select%20TOP%2010%20username%20from%20users))='a','a','b')%00`

т.е. TRUE, если первый символ равен 'a', и false в противном случае.

Как уже упоминалось, этот метод позволяет определить значение произвольных строк в базе данных:

1. Пробуя все печатные символы, пока не найдётся совпадение
2. Определяя длину строки с помощью функции `LEN` или просто остановившись после того, как найдены все символы.

Слепые SQL-инъекции, основанные на времени, также возможны при злоупотреблении [тяжёлыми запросами](https://docs.microsoft.com/en-us/previous-versions/tn-archive/cc512676(v=technet.10)).

## Ссылки

- [Памятка по SQL-инъекциям в MS Access](http://nibblesec.org/files/MSAccessSQLi/MSAccessSQLi.html)
- [Access Through Access - Brett Moore](https://packetstormsecurity.com/files/65967/Access-Through-Access.pdf.html)
- [Access SQL Injection - Brett Moore](https://seclists.org/pen-test/2003/May/74)
- [MS Access: Functions](https://www.techonthenet.com/access/functions/index_alpha.php)
- [Microsoft Access - Wikipedia](https://ru.wikipedia.org/wiki/Microsoft_Access)
