---

layout: col-document
title: WSTG - Latest
tags: WSTG

---

{% include breadcrumb.html %}
# Тестирование незащищённых параметров сессии

|ID          |
|------------|
|WSTG-SESS-04|

## Обзор

Незащищённые сессионные токены (Cookie, Session ID, скрытые поля) обычно позволяют злоумышленнику выдать себя за жертву и получить незаконный доступ к приложению. Важно, чтобы они всегда были защищены от раскрытия, особенно во время передачи между браузером и серверами приложений.

Приведённая здесь информация относится к тому, как транспортная безопасность применяется к передаче чувствительных Session ID, а не к данным в целом, и может быть более строгой, чем политики кэширования и передачи, применяемые к данным, обслуживаемым сайтом.

Используя HTTP-прокси, можно о каждом запросе и ответе узнать:

- используемый протокол (например, HTTP или HTTPS)
- HTTP-заголовки
- тело сообщения (например, POST или контент страницы)

Каждый раз, когда Session ID передаются между клиентом и сервером, следует проверять директивы протокола, кэша и конфиденциальности, а также тело. Транспортная безопасность здесь относится к Session ID, передаваемым в запросах GET или POST, текстах сообщений или другими способами через допустимые HTTP-запросам.

## Задачи тестирования

- Убедиться, что реализовано надлежащее шифрование.
- Проанализировать настройки кэширования.
- Оценить защиту канала передачи и HTTP-методов.

## Как тестировать

### Тестирование уязвимостей шифрования и повторного использования сессионных токенов

Защита от "прослушивания" канала часто обеспечивается TLS-шифрованием, но может включать и другие методы туннелирования или шифрования. Следует отметить, что шифрование или криптографическое хэширование Session ID следует рассматривать отдельно от транспортного шифрования, поскольку защищается сам Session ID, а не данные, которые могут быть им представлены.

Если Session ID может быть предоставлен злоумышленником приложению для получения доступа, то он должен быть защищён при передаче, чтобы снизить этот риск. Поэтому следует убедиться, чтобы по умолчанию для любого запроса или ответа, в котором передаётся Session ID, независимо от используемого механизма (например, скрытое поле формы) принудительно применялось шифрование. Для того, чтобы определить, реализовано ли адекватное разделение между защищёнными и незащищёнными сайтами необходимо проводить простые проверки, например, заменить `https://` на `http://` во время взаимодействия с приложением, а также изменять запросы POST в формах.

Обратите внимание, что если на сайте также есть элементы, где пользователь отслеживается с помощью Session ID, но защита отсутствует (например, для отслеживания, какие общедоступные документы загружает зарегистрированный пользователь), важно, чтобы использовался другой Session ID. Поэтому необходимо контролировать, когда клиент переключается с защищённых элементов на незащищенные, чтобы убедиться, что используется другой Session ID.

> Каждый раз, когда аутентификация проходит успешно, пользователь должен ожидать:
>
> - Другой сессионный токен.
> - Токен отправляется по зашифрованному каналу каждый раз, когда он делает HTTP-запрос.

### Тестирование уязвимостей прокси-серверов и кэширования

При анализе безопасности приложений также необходимо учитывать прокси-серверы. Во многих случаях клиенты получают доступ к приложению через прокси-серверы своей организации, интернет-провайдера или другие шлюзы с поддержкой протокола (например, межсетевые экраны). Протокол HTTP предоставляет директивы для управления поведением нижестоящих прокси-серверов, и необходимо оценивать правильность реализации этих директив.

В общем случае Session ID никогда не должен передаваться по незашифрованному каналу и никогда не должен кэшироваться. Приложение должно быть исследовано, чтобы убедиться, что как по умолчанию, так и принудительно при любой передаче Session ID используются зашифрованные сообщения. Кроме того, всякий раз, когда передаётся Session ID, должны быть установлены директивы, предотвращающие его кэширование промежуточными и даже локальными кэшами.

Приложение также должно быть настроено на защиту данных в кэшах как по HTTP/1.0, так и по HTTP/1.1 — в RFC 2616 обсуждаются соответствующие элементы управления со ссылкой на HTTP. HTTP/1.1 предоставляет ряд механизмов управления кэшем. `Cache-Control: no-cache` указывает, что прокси-сервер не должен повторно использовать какие-либо данные. Хотя `Cache-Control: Private` кажется подходящей директивой, она по-прежнему позволяет непубличному прокси-серверу кэшировать данные. В случае интернет-кафе или других общих систем это представляет собой явный риск. Кэшированный Session ID может быть раскрыт даже на однопользовательских рабочих станциях из-за компрометации файловой системы или использования сетевых хранилищ. HTTP/1.0 не поддерживает директиву `Cache-Control: no-cache`.

> Директивы `Expires: 0` и `Cache-Control: max-age=0` следует использовать для дополнительной гарантии того, что кэши не раскрывают данные. Должен быть проверен каждый запрос/ответ, передающий данные Session ID, чтобы убедиться, что используются соответствующие директивы кэша.

### Тестирование на уязвимости в GET и POST

Как правило, не следует использовать запросы GET, так как Session ID может отображаться в журналах прокси-сервера или межсетевого экрана. Ими также гораздо легче манипулировать, чем другими методами, хотя следует отметить, что клиент может манипулировать практически любым механизмом с помощью соответствующих инструментов. Кроме того, атаки [межсайтового скриптинга (XSS)](https://owasp.org/www-community/attacks/xss/) легче всего реализовать, отправляя жертве специально созданную ссылку. Это гораздо менее вероятно, если данные отправляются от клиента в виде POST.

Весь код на стороне сервера, получающий данные из запросов POST, должен быть протестирован, чтобы убедиться, что он не принимает данные, если они отправлены в GET. Например, рассмотрим следующий запрос POST (`http://owaspapp.com/login.asp`), сгенерированный страницей входа.

```http
POST /login.asp HTTP/1.1
Host: owaspapp.com
[...]
Cookie: ASPSESSIONIDABCDEFG=ASKLJDLKJRELKHJG
Content-Length: 51

Login=Username&password=Password&SessionID=12345678
```

Если login.asp реализован плохо, возможно, удастся войти в систему, используя следующий URL: `http://owaspapp.com/login.asp?Login=Username&password=Password&SessionID=12345678`

Таким образом, с помощью проверки каждого POST можно найти потенциально небезопасные скрипты на стороне сервера.

### Тестирование уязвимостей канала передачи

Взаимодействие между клиентом и приложением должно быть проверено, по крайней мере, на соответствие следующим критериям.

- Как передаются Session ID? например, в GET, POST, поле формы (включая скрытые)
- Всегда ли Session IDs передаются по зашифрованному каналу по умолчанию?
- Можно ли манипулировать приложением, чтобы отправлять Session IDs в незашифрованном виде? например, изменив HTTPS на HTTP?
- Какие директивы по управлению кэшем применяются к запросам/ответам, передающим Session IDs?
- Всегда ли присутствуют эти директивы? Если нет, то где исключения?
- Используются ли запросы GET, содержащие Session ID?
- Если используется POST, можно ли его заменить на GET?

## Ссылки

### Технические руководства

- [RFCs 2109 & 2965 – HTTP State Management Mechanism [D. Kristol, L. Montulli]](https://www.ietf.org/rfc/rfc2965.txt)
- [RFC 2616 – Hypertext Transfer Protocol - HTTP/1.1](https://www.ietf.org/rfc/rfc2616.txt)
