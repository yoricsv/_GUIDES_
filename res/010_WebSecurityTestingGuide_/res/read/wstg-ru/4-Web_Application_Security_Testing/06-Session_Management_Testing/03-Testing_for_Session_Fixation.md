---

layout: col-document
title: WSTG - Latest
tags: WSTG

---

{% include breadcrumb.html %}
# Тестирование фиксации сессии

|ID          |
|------------|
|WSTG-SESS-03|

## Обзор

Фиксация сессии стала возможной благодаря небезопасной практике сохранения того же значения сессионных cookie до и после аутентификации. Обычно это происходит, когда сессионные cookie используются для хранения информации о состоянии до входа в систему, например, при добавлении товаров в корзину до аутентификации для оплаты.

При типичной эксплуатации уязвимостей с фиксацией сессии злоумышленник может получить набор сессионных cookie с целевого web-сайта без предварительной аутентификации. Затем, используя различные методы, он принудительно загружает эти cookie в браузер жертвы. Если жертва позже аутентифицируется на целевом web-сайте, а её cookie не обновятся при входе в систему, жертва будет идентифицирована по сессионным cookie, выбранным злоумышленником. Позже с помощью этих cookie злоумышленник может выдать себя за жертву.

Эту проблему можно решить, обновляя сессионные cookie после процесса аутентификации. Кроме того, атаку можно предотвратить, обеспечив целостность сессионных cookie. При рассмотрении сетевых атак, т.е. злоумышленников, контролирующих сеть жертвы, используйте полноценный [HSTS](https://ru.wikipedia.org/wiki/HSTS) или добавьте префикс `__Host-` / `__Secure-` к имени cookie.

Полноценная реализация HSTS обеспечивается, когда хост активирует HSTS для себя и всех своих поддоменов. Это описано в статье [Stefano Calzavara, Alvise Rabitti, Alessio Ragazzo, and Michele Bugliesi *Testing for Integrity Flaws in Web Sessions*](https://www.researchgate.net/profile/Stefano-Calzavara/publication/335822602_Testing_for_Integrity_Flaws_in_Web_Sessions/links/5da41c15299bf116fea4ae1e/Testing-for-Integrity-Flaws-in-Web-Sessions.pdf).

## Задачи тестирования

- Проанализировать механизм и процедуру аутентификации.
- Принудительно использовать cookie и оценить результат.

## Как тестировать

В этом разделе мы даём объяснение стратегии тестирования, которая будет показана далее.

Первым шагом является отправка запроса на тестируемый сайт (*например,* `www.example.com`). Если тестировщик запрашивает:

```http
GET / HTTP/1.1
Host: www.example.com
```

то получит следующий ответ:

```http
HTTP/1.1 200 OK
Date: Wed, 14 Aug 2008 08:45:11 GMT
Server: IBM_HTTP_Server
Set-Cookie: JSESSIONID=0000d8eyYq3L0z2fgq10m4v-rt4:-1; Path=/; secure
Cache-Control: no-cache="set-cookie,set-cookie2"
Expires: Thu, 01 Dec 1994 16:00:00 GMT
Keep-Alive: timeout=5, max=100
Connection: Keep-Alive
Content-Type: text/html;charset=Cp1254
Content-Language: en-US
```

Приложение устанавливает для клиента новый идентификатор сессии `JSESSIONID=0000d8eyYq3L0z2fgq10m4v-rt4:-1`.

Затем, если тестировщик успешно аутентифицируется в приложении с помощью следующего POST на `https://www.example.com/authentication.php`:

```http
POST /authentication.php HTTP/1.1
Host: www.example.com
[...]
Referer: http://www.example.com
Cookie: JSESSIONID=0000d8eyYq3L0z2fgq10m4v-rt4:-1
Content-Type: application/x-www-form-urlencoded
Content-length: 57

Name=Meucci&wpPassword=secret!&wpLoginattempt=Log+in
```

то получает следующий ответ от сервера:

```http
HTTP/1.1 200 OK
Date: Thu, 14 Aug 2008 14:52:58 GMT
Server: Apache/2.2.2 (Fedora)
X-Powered-By: PHP/5.1.6
Content-language: en
Cache-Control: private, must-revalidate, max-age=0
X-Content-Encoding: gzip
Content-length: 4090
Connection: close
Content-Type: text/html; charset=UTF-8
...
HTML data
...
```

Раз после успешной аутентификации новый сессионный cookie не создаётся, а его целостность не гарантируется, то тестировщик знает, что можно провести перехват сессии.

Тестировщик может отправить действующий идентификатор сессии пользователю (например, используя социальную инженерию), дождаться его аутентификации и потом убедиться, что этому cookie назначены привилегии.

### Тест с принудительным cookie

Эта стратегия тестирования нацелена на сетевых нарушителей, поэтому её нужно применять только к сайтам с неполноценным HSTS (сайты с полным HSTS защищены, т.к. для их cookie обеспечена целостность). Мы предполагаем, что на тестируемом web-сайте есть две тестовые учётные записи, одна из которых выступает в качестве жертвы, а другая — злоумышленника. Мы моделируем сценарий, в котором злоумышленник принудительно загружает в браузер жертвы все cookie, которые не выпущены сразу после входа в систему и не гарантируют целостности. После входа жертвы в систему злоумышленник предъявляет принудительные cookie web-сайту для доступа к учётной записи жертвы: если их достаточно, чтобы действовать от имени жертвы, возможна фиксация сессии.

Ниже шаги для выполнения этого теста:

1. Перейдите на страницу входа на web-сайт.
2. Сохраните копию хранилища cookie перед входом в систему, за исключением cookie с префиксом `__Host-` или `__Secure-` в своём имени.
3. Войдите на web-сайт в качестве жертвы и перейдите на любую страницу, требующую аутентификации.
4. Запишите в хранилище cookie копию, сделанную на втором шаге.
5. Вызовите защищённую функцию, указанную на третьем шаге.
6. Проверьте, успешно ли выполнена операция на шаге 5. Если да, то атака удалась.
7. Очистите хранилище cookie, войдите в систему как злоумышленник и перейдите на страницу, найденную на шаге 3.
8. Запишите в хранилище один за другим cookie, сохранённые на шаге 2.
9. Снова вызовите функцию, указанную на шаге 3.
10. Очистите хранилище cookie и снова войдите в систему как жертва.
11. Проверьте, успешно ли выполнена операция на шаге 9 в учётной записи жертвы. Если да, то атака прошла успешно; в противном случае сайт защищён от фиксации сессии.

Мы рекомендуем использовать два разных компьютера или браузера для жертвы и злоумышленника. Это позволяет уменьшить количество ложных срабатываний, если web-приложение выполняет снятие отпечатков (fingerprinting) для подтверждения доступа, разрешённого с данным cookie. Более короткий, но менее точный вариант стратегии тестирования требует только одной тестовой учётной записи. Он следует тем же шагам, но останавливается на шаге 6.

## Меры защиты

Обновляйте сессионный токен после успешной аутентификации пользователя.

Приложение прежде чем аутентифицировать пользователя сначала должно аннулировать существующий Session ID, а, если аутентификация прошла успешно, предоставить ему другой Session ID.

## Инструменты

- [OWASP ZAP](https://www.zaproxy.org)

## Ссылки

- [Session Fixation](https://owasp.org/www-community/attacks/Session_fixation)
- [ACROS Security](https://www.acrossecurity.com/papers/session_fixation.pdf)
- [Chris Shiflett](http://shiflett.org/articles/session-fixation)
