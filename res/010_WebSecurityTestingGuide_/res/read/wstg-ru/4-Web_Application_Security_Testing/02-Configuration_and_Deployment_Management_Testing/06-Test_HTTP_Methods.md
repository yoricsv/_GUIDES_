---

layout: col-document
title: WSTG - Latest
tags: WSTG

---

{% include breadcrumb.html %}
# Тестирование методов HTTP

|ID          |
|------------|
|WSTG-CONF-06|

## Обзор

HTTP предлагает ряд методов (или глаголов), которые можно использовать для выполнения действий на web-сервере. Хотя на сегодняшний день GET и POST являются наиболее распространёнными методами для доступа к информации, предоставляемой web-сервером, существует множество других, которые также могут поддерживаться и иногда использоваться злоумышленниками.

[RFC 7231](https://datatracker.ietf.org/doc/html/rfc7231) определяет основные допустимые методы HTTP-запросов (или глаголы), хотя в других RFC были добавлены дополнительные методы, например, в [RFC 5789](https://datatracker.ietf.org/doc/html/rfc5789). Некоторые из этих глаголов были переиспользованы с разным назначением в приложениях [RESTful](https://en.wikipedia.org/wiki/Representational_state_transfer) перечисленных в таблице ниже.

| Метод | Первоначальное назначение | Назначение в RESTful |
|--------|------------------|-----------------|
| [`GET`](https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.1) | Запросить файл | Запросить объект|
| [`HEAD`](https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.2) | Запросить файл, но вернуть только HTTP-заголовки | |
| [`POST`](https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.3) | Передать данные | |
| [`PUT`](https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.4) | Загрузить файл | Создать объект |
| [`DELETE`](https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.5) | Удалить файл | Удалить объект |
| [`CONNECT`](https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.6) | Установить соединение с другой системой | |
| [`OPTIONS`](https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.7) | Перечислить поддерживаемые HTTP-методы | Выполнить запрос [CORS Preflight](https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request).
| [`TRACE`](https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.8) | Повторите HTTP-запрос с целью отладки | |
| [`PATCH`](https://datatracker.ietf.org/doc/html/rfc5789#section-2) |  | Изменить объект |

## Задачи тестирования

- Определить поддерживаемые HTTP-методы.
- Протестировать обход контроля доступа.
- Протестировать способы переопределения HTTP-методов.

## Как тестировать

### Определить поддерживаемые методы

Для выполнения этого теста необходимо определить, какие методы HTTP поддерживаются проверяемым web-сервером. Самый простой способ — отправить запрос `OPTIONS` на сервер:

```http
OPTIONS / HTTP/1.1
Host: example.org
```

На что сервер должен ответить перечнем поддерживаемых методов:

```http
HTTP/1.1 200 OK
Allow: OPTIONS, GET, HEAD, POST
```

Однако некоторые серверы могут не отвечать на запросы `OPTIONS` или возвращать неверную информацию. Кроме того, серверы могут поддерживать разные методы для разных путей, так что если метод не поддерживается для корневого каталога `/`, это не обязательно означает, что он не будет поддерживаться где-либо ещё.

Более надёжный способ проверки поддерживаемых методов — просто сделать запрос с этим типом метода и изучить ответ сервера. Если метод не разрешён, сервер должен вернуть статус `405 Method Not Allowed`.

Обратите внимание, что некоторые серверы считают все неизвестные им методы за `GET`, поэтому могут отвечать на произвольные методы, такие как запрос, показанный ниже. Иногда это может быть полезно для обхода WAF или другой фильтрации, блокирующей определённые методы.

```http
FOO / HTTP/1.1
Host: example.org
```

Запросы произвольными методами также можно выполнять с помощью curl с параметром `-X`:

```bash
curl -X FOO https://example.org
```

Существует также множество автоматизированных инструментов, которые могут пытаться определить поддерживаемые методы, таких как NSE-скрипт Nmap [`http-methods`](https://nmap.org/nsedoc/scripts/http-methods.html). Однако эти инструменты могут не проверять опасные методы (т. е. методы, которые могут вызывать изменения, такие как `PUT` или `DELETE`), или могут непреднамеренно вызывать изменения на web-сервере, если эти методы поддерживаются. Поэтому их следует применять с осторожностью.

### PUT и DELETE

Методы `PUT` и `DELETE` могут приводить к разным результатам, в зависимости от того, интерпретируются ли они web-сервером или запущенным на нём приложением.

#### Устаревшие web-серверы

Некоторые ныне устаревшие web-серверы позволяли использовать метод `PUT` для создания файлов на сервере. Например, если это разрешено настройками, то приведённый ниже запрос создаст на сервере файл с именем `test.html` и содержимым `<script>alert(1)</script>`.

```http
PUT /test.html HTTP/1.1
Host: example.org
Content-Length: 25

<script>alert(1)</script>
```

Подобные запросы также можно сделать с помощью cURL.:

```bash
curl https://example.org --upload-file test.html
```

Это позволяет злоумышленнику загружать произвольные файлы на web-сервер, что потенциально может привести к полной компрометации системы, если разрешено загружать исполняемый код, например, файлы PHP. Однако такая конфигурация встречается крайне редко и вряд ли будет обнаружена в современных системах.

Аналогичным образом, метод `DELETE` можно использовать для удаления файлов с web-сервера. Обратите внимание, что это **разрушительное воздействие**, поэтому если собираетесь его использовать, соблюдайте осторожность.

```http
DELETE /test.html HTTP/1.1
Host: example.org
```

Или с cURL:

```bash
curl http://example.org/test.html -X DELETE
```

#### RESTful API

Напротив, методы `PUT` and `DELETE` часто используются современными RESTful-приложениями для создания и удаления объектов. Например, приведённый ниже API-запрос может быть использован для создания пользователя с именем foo с ролью user:

```http
PUT /api/users/foo HTTP/1.1
Host: example.org
Content-Length: 34

{
    "role": "user"
}
```

Аналогичный запрос с методом `DELETE` можно использовать для удаления объекта.

```http
DELETE /api/users/foo HTTP/1.1
Host: example.org
```

Хотя инструменты автоматического сканирования и могут предупреждать об этом, но наличие этих методов в RESTful API **не является проблемой безопасности**. Однако эта функциональность может иметь другие уязвимости (например, слабый контроль доступа) и должна быть тщательно протестирована.

### TRACE

Метод `TRACE` (или его эквивалент от Microsoft — `TRACK`) заставляет сервер возвращать содержимое запроса. Это привело к публикации в 2003 году ([PDF](https://www.cgisecurity.com/whitehat-mirror/WH-WhitePaper_XST_ebook.pdf)) уязвимости под названием Cross-Site Tracing (XST), которую можно было использовать для доступа к файлам cookie с установленным флагом `HttpOnly`. Метод `TRACE` уже многие годы как заблокирован во всех браузерах и плагинах, и поэтому его больше нельзя эксплуатировать. Тем не менее, он всё ещё может быть отмечен автоматическими инструментами сканирования, а метод `TRACE` включенный на web-сервере, предполагает, что защита сервера должным образом не укреплена.

### CONNECT

Метод `CONNECT` заставляет web-сервер открывать TCP-соединение с другой системой, а затем передавать трафик от клиента в эту систему. Это может позволить злоумышленнику проксировать трафик через сервер, чтобы скрыть свой исходный адрес, получить доступ к внутренним системам или получить доступ к службам, привязанным к локальному хосту. Пример запроса `CONNECT` показан ниже:

```http
CONNECT 192.168.0.1:443 HTTP/1.1
Host: example.org
```

### PATCH

Метод `PATCH` определён в [RFC 5789](https://datatracker.ietf.org/doc/html/rfc5789), и используется для предоставления инструкций по изменению объекта. Сам RFC не определяет, в каком формате должны быть эти инструкции, но различные методы определены в других стандартах, например, в [RFC 6902 - JavaScript Object Notation (JSON) PATCH](https://datatracker.ietf.org/doc/html/rfc6902).

Например, если у нас есть пользователь с именем foo со следующими атрибутами:

```json
{
    "role": "user",
    "email": "foo@example.org"
}
```

Для изменения роли этого пользователя на admin, не изменяя email, можно использовать такой запрос JSON PATCH:

```http
PATCH /api/users/foo HTTP/1.1
Host: example.org

{ "op": "replace", "path": "/role", "value": "admin" }
```

Хотя в RFC указано, что запрос должен включать инструкции о том, как должен изменяться весь объект, метод `PATCH` вместо этого обычно (зло-) употребляется для включения только изменённого содержимого, как показано ниже. Как и в предыдущем запросе, это приведёт к изменению значения role на admin без изменения остальной части объекта. В этом его отличие от метода `PUT` который перезаписывает весь объект (что оставило бы его без атрибута email).

```http
PATCH /api/users/foo HTTP/1.1
Host: example.org

{
    "role": "admin"
}
```

Как и в случае с методом `PUT`, эта функциональность может иметь слабые места в контроле доступа или другие уязвимости. Кроме того, приложения при изменении объекта могут не обеспечивать тот же уровень контроля входных данных, что и при его создании. Это потенциально может привести к инъекции вредоносных значений (например, при атаке с использованием хранимых межсайтовых скриптов) или может привести к повреждению или недопустимым объектам, что может стать причиной проблем, связанных с бизнес-логикой.

### Тестирование обхода контроля доступа

Если страница приложения при попытке получить доступ к ней напрямую перенаправляет пользователей на страницу входа с кодом `302`, можно обойти это, выполнив запрос с другим методом HTTP, например `HEAD`, `POST` или даже выдуманным методом, например, `FOO`. Если web-приложение отвечает `HTTP/1.1 200 OK`, вместо ожидаемого `HTTP/1.1 302 Found` возможно, получится обойти аутентификацию или авторизацию. В приведённом ниже примере показано, как запрос `HEAD` может привести к тому, что страница установит cookie для сессии администратора, а не перенаправит пользователя на страницу входа в систему:

```http
HEAD /admin/ HTTP/1.1
Host: example.org
```

```http
HTTP/1.1 200 OK
[...]
Set-Cookie: adminSessionCookie=[...];
```

В качестве альтернативы можно делать прямые запросы к страницам, которые вызывают действия, например:

```http
HEAD /admin/createUser.php?username=foo&password=bar&role=admin HTTP/1.1
Host: example.org
```

Или:

```http
FOO /admin/createUser.php
Host: example.org
Content-Length: 36

username=foo&password=bar&role=admin
```

### Тестирование переопределения HTTP-метода

Некоторые web-фреймворки предоставляют способ переопределить фактический HTTP-метод в запросе, эмулируя отсутствующие HTTP-глаголы, передачей пользовательского заголовка в запросах. Основная цель этого — обойти приложение промежуточного слоя (например, прокси-сервер или WAF), которое блокирует те или иные методы. Потенциально могут быть использованы следующие альтернативные HTTP-заголовки:

- `X-HTTP-Method`
- `X-HTTP-Method-Override`
- `X-Method-Override`

Чтобы проверить это, в сценариях, где запрещённые глаголы, такие как `PUT` или `DELETE` выдают `405 Method not allowed`, повторите тот же запрос, добавив альтернативный заголовок для переопределения HTTP-метода и понаблюдайте за реакцией системы. Если переопределение методов поддерживается, то приложение должно отвечать другим кодом состояния (*например*, `200 OK`).

В следующем примере web-сервер не разрешает метод `DELETE` и блокирует его:

```http
DELETE /resource.html HTTP/1.1
Host: example.org
```

```http
HTTP/1.1 405 Method Not Allowed
[...]
```

После добавления заголовка `X-HTTP-Method`, сервер отвечает на запрос кодом 200:

```http
GET /resource.html HTTP/1.1
Host: example.org
X-HTTP-Method: DELETE
```

```http
HTTP/1.1 200 OK
[...]
```

## Меры защиты

- Убедитесь, что разрешены только требуемые методы и что разрешённые методы корректно настроены.
- Убедитесь в неработоспособности путей для обхода мер защиты, реализованных пользовательскими агентами, фреймворками или web-серверами..

## Инструменты

- [Ncat](https://nmap.org/ncat/)
- [cURL](https://curl.haxx.se/)
- [Nmap http-methods NSE script](https://nmap.org/nsedoc/scripts/http-methods.html)

## Ссылки

- [RFC 7231 - Протокол передачи гипертекста (HTTP/1.1)](https://datatracker.ietf.org/doc/html/rfc7231)
- [RFC 5789 - Метод PATCH для HTTP](https://datatracker.ietf.org/doc/html/rfc5789)
- [HTACCESS: Разоблачение метода BILBAO](https://web.archive.org/web/20160616172703/http://www.kernelpanik.org/docs/kernelpanik/bme.eng.pdf)
- [Fortify - Злоупотребление переопределением HTTP-методов](https://vulncat.fortify.com/en/detail?id=desc.dynamic.xtended_preview.often_misused_http_method_override)
- [Mozilla Developer Network - Безопасные методы HTTP](https://developer.mozilla.org/en-US/docs/Glossary/Safe/HTTP)
