---

layout: col-document
title: WSTG - Latest
tags: WSTG

---

{% include breadcrumb.html %}
# Анализ старых резервных копий и файлов без ссылок

|ID          |
|------------|
|WSTG-CONF-04|

## Обзор

Хотя большинство файлов web-сервера обрабатываются непосредственно самим сервером, нередко можно найти неиспользуемые или файлы без ссылок, которые можно использовать для получения важной информации об инфраструктуре или учётных данных.

В наиболее распространённые сценарии входит наличие переименованных старых версий изменённых файлов, файлов include, которые подключаются на выбранном языке и могут быть подгружены в виде исходного кода; или даже автоматически или вручную созданные резервные копии в виде сжатых архивов. Файлы резервных копий также могут создаваться автоматически базовой файловой системой, в которой размещено приложение, и эта функция обычно называется «моментальными снимками» (снэпшотами).

В этих файлах может обнаружиться доступ к внутренним проектам, бэкдоры, оставленные разработчиками, или даже учётные данные для подключения к административному интерфейсу или серверу базы данных.

Важным источником уязвимости являются файлы, которые не имеют ничего общего с приложением, но создаются в результате редактирования файлов приложения, либо при создании промежуточных резервных копий, либо в web-каталогах остаются старые или забытые файлы. Редактирование или администрирование непосредственно на рабочих web-серверах может непреднамеренно оставить после себя резервные копии, созданные автоматически редактором при изменении файлов, или администратором для архивации файлов при создании резервной копии.

Такие файлы легко забыть, и это может представлять серьёзную угрозу безопасности приложения. Это происходит потому, что резервные копии могут создаваться с расширениями файлов, отличными от исходных файлов. Архив `.tar`, `.zip` или `.gz`, который мы создаём (и сразу забываем...), очевидно, имеет другое расширение, и то же самое происходит с автоматическими копиями, создаваемыми многими редакторами (например, emacs при редактировании `file` создаёт резервную копия с именем `file~`). Создание копии вручную может дать тот же эффект (например, `file` переименовывается в `file.old`). Базовая файловая система, в которой находится приложение, может делать снэпшоты вашего приложения в разные моменты времени без вашего ведома, которые к тому же могут быть доступны через Интернет, создавая похожую угрозу типа «файл резервной копии» для вашего приложения.

В результате этих действий формируются файлы, которые не нужны приложению и могут обрабатываться web-сервером не так, как исходный файл. Например, если мы делаем копию `login.asp` с именем `login.asp.old`, мы разрешаем пользователям загружать исходный код `login.asp`. Это связано с тем, что `login.asp.old` обычно выводится как текст, а не исполняется (в соответствии с его расширением). Другими словами, доступ к `login.asp` вызывает выполнение серверного кода `login.asp`, а доступ к `login.asp.old` выводит содержимое `login.asp.old` (то есть, того самого кода на сервере) для отображения в виде простого текста в браузере пользователю. Это может представлять угрозу безопасности, поскольку может раскрываться конфиденциальная информация.

Вообще говоря, раскрытие кода, работающего на стороне сервера — плохая идея. Вы не только без необходимости раскрываете бизнес-логику, но и можете неумышленно раскрыть информацию о приложении, которая может помочь злоумышленнику (пути, структуры данных и т.д.). Не говоря уже о том, что там обычно слишком много скриптов с логином и паролем в открытом виде (что является необдуманной и очень опасной практикой).

Другие причины для появления файлов без ссылок связаны с выбором архитектуры или конфигурации, когда они позволяют хранить различные типы файлов, связанных с приложением, например, файлы данных, файлы конфигурации, файлы журналов, в каталогах файловой системы, к которым может получить доступ web-сервер. Обычно у этих файлов нет повода находиться в пространстве файловой системы, к которому можно получить доступ через Интернет, поскольку доступ к ним должен осуществляться только на уровне приложения самим приложением (а не случайным пользователем, просматривающим его).

### Угрозы

Старые резервные копии и файлы без ссылок представляют различные угрозы для безопасности web-приложения:

- Файлы без ссылок могут раскрывать конфиденциальную информацию, которая может способствовать целенаправленной атаке на приложение; например, включать файлы, содержащие учётные записи к базе данных, файлы конфигурации, содержащие ссылки на скрытое содержимое, абсолютные пути к файлам и т.д.
- Страницы без ссылок могут содержать административные функции, которые можно использовать для атаки на приложение; например, панель администрирования, на которую нет ссылок из опубликованного контента, но доступ к которой может получить любой пользователь, знающий, где её найти.
- Старые файлы и резервные копии могут содержать уязвимости, которые исправлены в более поздних версиях; например, `viewdoc.old.jsp` может содержать уязвимость обхода каталогов, которая исправлена в `viewdoc.jsp`, но ещё может быть использована любым, кто найдёт старую версию.
- Файлы резервных копий могут раскрывать исходный код страниц, предназначенных для выполнения на сервере; например, запрос `viewdoc.bak` может вывести исходный код `viewdoc.jsp`, который можно проанализировать на наличие уязвимостей. Которые в свою очередь может быть трудно найти, выполняя запросы к исполняемой странице вслепую. Хотя эта угроза явно относится к скриптовым языкам, таким как Perl, PHP, ASP, shell-скрипты, JSP и т.д., она не ограничивается только ими, как показано в примере, представленном в следующем пункте.
- Архивы резервных копий могут содержать копии всех файлов внутри (или даже за пределами) webroot. Это позволяет злоумышленнику быстро проинвентаризировать всё приложение, включая страницы без ссылок, исходный код, файлы include и т.д. Например, если вы забыли файл с именем `myservlets.jar.old`, содержащий (резервную копию) ваши классы реализации сервлетов, вы даёте злоумышленникам много конфиденциальной информации, которая подвержена декомпиляции и реверс-инжинирингу.
- В некоторых случаях копирование или редактирование файла изменяет не расширение файла, а его имя. Это происходит, например, в среде Windows, где при копировании создаются имена файлов с префиксом «Копия» или локализованными версиями этой строки. Поскольку расширение файла остается неизменным, это не тот случай, когда исполняемый файл выводится web-сервером в виде простого текста, и, следовательно, не является случаем раскрытия исходного кода. Однако и эти файлы опасны, т.к. есть вероятность, что они содержат устаревшую и неправильную логику, которая может вызвать ошибки приложения, которые могут раскрыть злоумышленнику ценную информацию, если включено отображение диагностических сообщений.
- Файлы журналов могут содержать чувствительную информацию о действиях пользователей приложения, например конфиденциальные данные, передаваемые в параметрах URL-адреса, идентификаторы сессии, посещённые URL-адреса (которые могут раскрывать дополнительный непубличный контент) и т.д. Другие файлы журналов (например, журналы ftp) могут содержать конфиденциальную информацию. о сопровождении приложения системными администраторами.
- Снэпшоты файловой системы могут содержать копии кода с уязвимостями, которые были устранены в более поздних версиях. Например, `/.snapshot/monthly.1/view.php` может содержать уязвимость обхода каталога, которая уже исправлена в `/view.php`, но всё ещё может быть проэксплуатирована тем, кто найдёт старую версию.

## Задача тестирования

- Найти и проанализировать файлы без ссылок, которые могут содержать конфиденциальную информацию.

## Как тестировать

### Тестирование методом «чёрного ящика»

При тестировании файлов без ссылок используются как автоматические, так и ручные методы. Обычно оно включает в себя комбинацию из следующего:

#### Вывод из соглашения о наименовании для опубликованного контента

Проинвентаризируйте все страницы и функции приложения. Это можно сделать вручную с помощью браузера или с помощью инструмента для сканирования. Большинство приложений применяют легко угадываемое соглашение о наименовании и организуют ресурсы в страницы и каталоги, используя слова, которые описывают их функции. Из соглашения о наименовании для опубликованного контента, часто можно сделать вывод о названии и местоположении страниц, на которые нет ссылок. Например, если найдена страница `viewuser.asp`, ищите также `edituser.asp`, `adduser.asp` и `deleteuser.asp`. Если найден каталог `/app/user`, ищите также `/app/admin` и `/app/manager`.

#### Другие подсказки в опубликованном контенте

Многие web-приложения оставляют подсказки в опубликованном контенте, которые могут привести к обнаружению скрытых страниц и функций. Эти подсказки часто появляются в исходном коде файлов HTML и JavaScript. Исходный код для всего опубликованного контента должен быть проверен вручную, чтобы выявить подсказки о других страницах и функциях. Например:

Комментарии программистов и закомментированные участки исходного кода могут относиться к скрытому содержимому:

```html
<!-- <A HREF="uploadfile.jsp">Загрузить документ на сервер</A> -->
<!-- Ссылка удалена, т.к. ошибки в uploadfile.jsp исправлены.          -->
```

JavaScript может содержать ссылки на страницы, которые отображаются в графическом интерфейсе пользователя только при определённых обстоятельствах:

```javascript
var adminUser=false;
if (adminUser) menu.add (new menuItem ("Сопровождение пользователей", "/admin/useradmin.jsp"));
```

HTML-страницы могут содержать FORM'ы , которые были скрыты из-за отключения элемента SUBMIT:

```html
<form action="forgotPassword.jsp" method="post">
    <input type="hidden" name="userID" value="123">
    <!-- <input type="submit" value="Забыт пароль"> -->
</form>
```

Другим источником подсказок о каталогах без ссылок является `/robots.txt ` файл, используемый для предоставления инструкций web-сканерам:

```html
User-agent: *
Disallow: /Admin
Disallow: /uploads
Disallow: /backup
Disallow: /~jbloggs
Disallow: /include
```

#### Угадывание

В своей простейшей форме это включает в себя прогон списка распространённых имён файлов через механизм запросов в попытке угадать файлы и каталоги, которые есть на сервере. Следующий скрипт netcat считывает список слов из stdin и проводит базовую атаку угадывания:

```bash
#!/bin/bash

server=example.org
port=80

while read url
do
echo -ne "$url\t"
echo -e "GET /$url HTTP/1.0\nHost: $server\n" | netcat $server $port | head -1
done | tee outputfile
```

В зависимости от сервера GET можно заменить на HEAD, если надо получить результат быстрее. В указанном выходном файле можно найти «интересные» коды ответов. Код ответа 200 (OK) обычно указывает на то, что был найден действующий ресурс (при условии, что сервер не выдаёт нестандартную страницу «Не найдено» с кодом 200). Также обратите внимание на 301 (Moved), 302 (Found), 401 (Unauthorized), 403 (Forbidden) и 500 (Internal error), которые также могут указывать на ресурсы или каталоги, заслуживающие дальнейшего изучения.

Базовая атака угадывания должна проводиться против webroot, а также против всех каталогов, которые были обнаружены с помощью других методов инвентаризации. Более продвинутые и эффективные атаки на угадывание могут быть проведены следующим образом:

- Определите расширения файлов, используемые в известных областях приложения (например, jsp, aspx, html), и используйте базовый список слов, добавляя к ним каждое из этих расширений (или используйте более длинный список распространённых расширений, если позволяют ресурсы).
- Для каждого файла, идентифицированного с помощью других методов инвентаризации, создайте собственный список слов, полученный из этого имени файла. Возьмите список распространенных расширений файлов (включая ~, bak, txt, src, dev, old, inc, orig, copy, tmp, swp и т. д.) и используйте каждое расширение до, после и вместо расширения фактического имени файла.

Примечание: Операции копирования файлов Windows генерируют имена файлов с префиксом «Копия» или локализованными версиями этой строки, поэтому они не изменяют расширения файлов. Хотя файлы «Копия» обычно не раскрывают исходный код при доступе к ним, они могут содержать ценную информацию в случае, если они вызывают ошибки при вызове.

#### Информация, полученная из-за уязвимостей сервера и неправильной конфигурации

Самый очевидный способ, с помощью которого неправильно сконфигурированный сервер может раскрыть страницы, на которые нет ссылок, — вывести листинг каталога. Запросите все перечисленные в нём каталоги, чтобы найти те из них, что выдают список каталогов.

На отдельных web-серверах были обнаружены многочисленные уязвимости, которые позволяют злоумышленнику находить контент, на который нет ссылок, например:

- Уязвимость листинга каталога Apache ?M=D.
- Различные уязвимости раскрытия исходного кода скриптов IIS.
- Уязвимости листинга каталога IIS WebDAV.

#### Использование общедоступной информации

Страницы и функциональные возможности в web-приложениях с выходом в Интернет, на которые нет ссылок в самом приложении, могут быть указаны в других общедоступных источниках. Существуют различные источники таких ссылок:

- Страницы, на которые раньше ссылались, все ещё могут отображаться в архивах поисковых систем Интернета. Например, `1998results.asp` уже может быть не связан с web-сайтом компании, но может оставаться на сервере и в базах данных поисковых систем. Этот старый скрипт может содержать уязвимости, которые можно использовать для компрометации всего сайта. Можно использовать оператор поиска Google `site:` для запроса только к выбранному домену, например: `site:www.example.com`. Использование поисковых систем таким образом привело к широкому спектру методов, которые могут оказаться для вас полезными. Они описаны в разделе [Google Hacking или Dorking](../01-Information_Gathering/01-Conduct_Search_Engine_Discovery_Reconnaissance_for_Information_Leakage.md) данного руководства. Попробуйте, чтобы отточить свои навыки тестирования через Google. На файлы резервных копий вряд ли кто будет ссылаться, и поэтому они могут быть не проиндексированы Google, но если они находятся в доступных для просмотра каталогах, поисковая система может о них знать.
- Кроме того, Google и Yahoo хранят в кэше версии страниц, найденных их роботами. Даже если `1998results.asp` был удалён с целевого сервера, версия его выдачи может по-прежнему храниться этими поисковыми системами. Кэшированная версия может содержать ссылки или подсказки о дополнительном скрытом содержимом, которое всё ещё остаётся на сервере.
- Контент, на который нет ссылок из целевого приложения, может быть связан со сторонними web-сайтами. Например, приложение, обрабатывающее онлайн-платежи от имени сторонних торгово-сервисных предприятий, может содержать множество специальных функций, которые (обычно) можно найти только по ссылкам на web-сайтах его клиентов.

#### Обход фильтра по имени файла

Поскольку фильтры по запрёщенным спискам основаны на регулярных выражениях, иногда можно воспользоваться малоизвестными функциями расширения имен файлов ОС, которые работают не так, как ожидал разработчик. Тестировщик иногда может использовать различия в способах анализа имён файлов приложением, web-сервером и базовой операционной системой, а также в соглашении о наименовании файлов.

Пример: как `c:\\program files` в соглашении о наименовании Windows 8.3 становится `C:\\PROGRA\~1`:

- Удалить несовместимые символы
- Преобразовать пробелы в символы подчёркивания
- Взять первые шесть символов базового имени
- Добавить `~<цифру>`, для различения с именами, начинающимися с тех же шести символов
- Это соглашение меняется после трёх конфликтов имён.
- Сократить расширение файла до трёх символов
- Перевести все символы в верхний регистр

### Тестирование методом «серого ящика»

Проведение тестирования методом «серого ящика» в отношении старых и резервных файлов требует анализа файлов, содержащихся в web-каталогах, обслуживаемых web-сервером(ами) инфраструктуры web-приложений. Теоретически исследование должно проводиться вручную, чтобы оно было тщательным. Однако, поскольку в большинстве случаев копии или файлы резервных копий, как правило, создаются с использованием одних и тех же соглашений о наименованиях, поиск можно легко реализовать скриптом. Например, редакторы оставляют резервные копии, называя их узнаваемым расширением или окончанием, а люди, как правило, оставляют после себя файлы с `.old` и тому подобными предсказуемыми расширениями. Хорошим правилом является запуск фонового задания по расписанию для поиска файлов с расширениями копий или резервных копий, а также проверка их вручную на регулярной основе.

## Меры защиты

Чтобы гарантировать эффективную стратегию защиты, тестирование должно дополняться политикой безопасности, которая категорически запрещает опасные действия, такие как:

- Редактирование файлов в файловых системах web-сервера или сервера приложений в эксплуатационной среде. Это особенно вредная привычка, поскольку редакторы могут создавать резервные копии или временные файлы. Удивительно видеть, как часто это делается, даже в крупных организациях. Если вам абсолютно необходимо редактировать файлы в среде эксплуатации, убедитесь, что вы не оставляете ничего, что не планировали, и учитывайте, что вы делаете это на свой страх и риск.
- Тщательно проверяйте все действия, проводимые в файловых системах, открываемых web-сервером в Интернет, например действия при точечном  администрировании. Например, если вам время от времени нужно делать снэпшот пары каталогов (чего не следует делать в эксплуатационной среде), у вас может возникнуть соблазн сначала заархивировать их. Следите, чтобы не оставить после себя эти архивные файлы.
- Соответствующие политики управления конфигурацией должны помочь предотвратить появление устаревших файлов и файлов без ссылок.
- Приложения должны быть спроектированы таким образом, чтобы не создавать (и не полагаться на) файлы, хранящиеся в деревьях web-каталогов, обслуживаемых web-сервером. Файлы данных, файлы журналов, файлы конфигурации и т. д. должны храниться в каталогах, недоступных для web-сервера, чтобы предотвратить возможность раскрытия информации (не говоря уже об изменении данных, если разрешения web-каталога позволяют запись).
- Снэпшоты файловой системы не должны быть доступны через Интернет, если корневой каталог документа находится в файловой системе, использующей эту технологию. Настройте свой web-сервер так, чтобы он запрещал доступ к таким каталогам, например, в Apache следует использовать директиву location:

```xml
<Location ~ ".snapshot">
    Order deny,allow
    Deny from all
</Location>
```

## Инструменты

В инструменты анализа уязвимостей, как правило, входят проверки для обнаружения web-каталогов со стандартными именами (например, admin, test, backup и т.д.), также они показывают web-каталоги, допускающие индексацию. Если вы не можете найти список каталогов, вам следует попытаться поискать по возможным расширениям резервных копий. Попробуйте, например

- [Nessus](https://www.tenable.com/products/nessus)
- [Nikto2](https://cirt.net/Nikto2)

Инструменты web-сканирования

- [wget](https://www.gnu.org/software/wget/)
- [Wget для Windows](http://www.interlog.com/~tcharron/wgetwin.html)
- [Sam Spade](https://web.archive.org/web/20090926061558/http://preview.samspade.org/ssw/download.html)
- [Spike proxy](https://www.spikeproxy.com/) (включает функцию web-сканирования)
- [Xenu](http://home.snafu.de/tilman/xenulink.html)
- [curl](https://curl.haxx.se)

Некоторые из них также включены в стандартные дистрибутивы Linux. В инструменты web-разработки обычно входят средства для выявления неработающих ссылок и файлов, на которые нет ссылок.
