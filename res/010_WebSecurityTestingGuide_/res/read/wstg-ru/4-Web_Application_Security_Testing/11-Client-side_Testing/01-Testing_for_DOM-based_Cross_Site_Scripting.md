---

layout: col-document
title: WSTG - Latest
tags: WSTG

---

{% include breadcrumb.html %}
# Тестирование XSS на основе DOM

|ID          |
|------------|
|WSTG-CLNT-01|

## Обзор

[Межсайтовый скриптинг на основе DOM](https://owasp.org/www-community/attacks/DOM_Based_XSS) — де-факто название [XSS-инъекций](https://owasp.org/www-community/attacks/xss/), возникающих в результате активного контента страницы в браузере, обычно JavaScript, который получает входные данные от пользователя в [источнике](https://github.com/wisec/domxsswiki/wiki/sources) (англ.: source) и использует их в [приёмнике](https://github.com/wisec/domxsswiki/wiki/Sinks) (англ.: sink), что ведёт к эксплуатации инъекции. В этом документе обсуждаются только ошибки JavaScript, которые приводят к XSS.

DOM, или объектная модель документа (англ.: [Document Object Model](https://ru.wikipedia.org/wiki/Document_Object_Model)) — это формат структуры, используемый для представления документов в браузере. DOM позволяет скриптам, например, на JavaScript, ссылаться на элементы документа, такие как поле формы или сессионный cookie. DOM также используется браузером для обеспечения безопасности — например, чтобы запретить скриптам с других доменов доступ к сессионным cookie. Уязвимость XSS на основе DOM может возникнуть, когда активный контент, например, функция JavaScript, модифицируется специально созданным запросом таким образом, чтобы элемент DOM мог контролироваться злоумышленником.

Не все XSS-атаки требуют от злоумышленника контроля над контентом, возвращаемым с сервера, вместо этого они могут эксплуатировать порочную практику разработки на JavaScript для достижения тех же целей. Последствия те же, что и у типичной XSS-атаки, отличаются только средства доставки.

По сравнению с другими типами уязвимостей межсайтового скриптинга ([отражённых и хранимых](https://owasp.org/www-community/attacks/xss/), когда сервер передаёт (без нейтрализации) параметр, затем возвращает пользователю и выполняет в контексте его браузера; уязвимость XSS на основе DOM управляет потоком кода с помощью элементов объектной модели документа (DOM) наряду с кодом, специально созданным злоумышленником для изменения этого потока.

Из-за своей природы уязвимости XSS на основе DOM могут выполняться в нескольких экземплярах, при этом сервер не сможет определить, что происходит на самом деле, что может сделать многие из общих методов фильтрации и обнаружения XSS бессильными перед такими атаками.

В этом гипотетическом примере на стороне клиента используется следующий код:

```html
<script>
document.write("Site is at: " + document.location.href + ".");
</script>
```

Злоумышленник может добавить `#<script>alert('xss')</script>` к URL уязвимой страницы, что при выполнении отобразит окно предупреждения. В этом случае добавленный код не передаётся на сервер, поскольку всё, что находится после символа `#`, обрабатывается браузером не как часть запроса, а как фрагмент URL. В этом примере код выполняется сразу, и на странице отображается предупреждение `xss`. В отличие от более распространённых типов межсайтового скриптинга ([отражённого и хранимого](https://owasp.org/www-community/attacks/xss/), при котором код передаётся на сервер, а затем обратно в браузер, этот выполняется непосредственно в браузере пользователя без взаимодействия с сервером.

[Последствия](https://owasp.org/www-community/attacks/xss/) XSS-атак на основе DOM столь же разнообразны, как и те, что наблюдаются в более известных формах XSS, включая извлечение cookie, дальнейшие инъекции вредоносных скриптов и т.д., и поэтому к ним следует относиться с той же серьёзностью.

## Задачи тестирования

- Найти приёмники DOM.
- Составить полезные нагрузки для каждого типа приёмника.

## Как тестировать

Приложения JavaScript значительно отличаются от других типов приложений, поскольку они часто генерируются сервером динамически. Чтобы понять, какой код выполняется, необходимо просканировать весь тестируемый web-сайт, чтобы найти все экземпляры выполняемого JavaScript и где принимаются данные от пользователя. Многие сайты полагаются на большие библиотеки функций, которые занимают сотни тысяч строк кода и разрабатывались извне. В этих случаях тестирование сверху вниз становится единственным жизнеспособным вариантом, поскольку многие функции нижнего уровня не нужны, а их анализ для определения того, какие из них являются приёмниками, отнимет больше времени, чем есть в наличии. То же самое можно сказать о тестировании сверху-вниз, когда входные данные или их отсутствие не известны с самого начала.

Данные поступают от пользователя в двух основных формах:

- входные данные записываются на страницу сервером таким образом, что прямой XSS не допускается, и
- входные данные получаются от объектов JavaScript на стороне клиента.

Вот два примера того, как сервер может вставлять данные в JavaScript:

```js
var data = "<экранированные данные с сервера>";
var result = someFunction("<экранированные данные с сервера>");
```

Два примера ввода из объектов JavaScript на стороне клиента:

```js
var data = window.location;
var result = someFunction(window.referrer);
```

Хотя в коде JavaScript не так много отличий в том, как они извлекаются, важно отметить, что при получении входных данных через сервер он может применять любые перестановки к данным, которые пожелает. С другой стороны, перестановки, выполняемые объектами JavaScript, довольно хорошо изучены и задокументированы. Если бы `someFunction` в приведённом выше примере была приёмником, то возможность эксплуатации в первом случае зависела бы от фильтрации на сервере, тогда как во втором случае это зависело бы от кодировки, применяемой браузером к объекту `window.referrer`. Stefano Di Paulo написал отличную статью о том, что браузеры выдают в ответ на запросы о различных элементах [URL, используя атрибуты document и location](https://github.com/wisec/domxsswiki/wiki/location,-documentURI-and-URL-sources).

Кроме того, JavaScript часто выполняется вне блоков `<script>`, , о чем свидетельствует множество векторов, которые в прошлом приводили к обходу фильтра XSS. При сканировании приложения важно учитывать использование скриптов в таких местах, как обработчики событий и блоки CSS с атрибутами выражений. Также обратите внимание, что необходимо будет проанализировать все внешние объекты CSS или script, чтобы определить, какой код там выполняется.

Автоматизированное тестирование имеет очень ограниченный успех в идентификации и подтверждении XSS на основе DOM, поскольку оно обычно идентифицирует XSS, передавая определённую полезную нагрузку и пытаясь наблюдать её в ответе сервера. Это может хорошо работать для приведённого ниже простого примера, где параметр сообщения отражается обратно пользователю:

```html
<script>
var pos=document.URL.indexOf("message=")+5;
document.write(document.URL.substring(pos,document.URL.length));
</script>
```

Однако XSS может быть не обнаружена в следующем выдуманном примере:

```html
<script>
var navAgt = navigator.userAgent;

if (navAgt.indexOf("MSIE")!=-1) {
        document.write("Вы используете браузер IE и находитесь на сайте: " + document.location.href + ".");
}
else
{
    document.write("Вы используете неизвестный браузер.");
}
</script>
```

По этой причине автоматизированное тестирование не обнаружит области, которые могут быть восприимчивы к XSS на основе DOM, если инструмент тестирования не способен провести дополнительный анализ кода на стороне клиента.

Поэтому следует проводить ручное тестирование путём изучения тех фрагментов кода, на которые ссылаются параметры, интересные злоумышленнику. Примерами таких фрагментов являются места, где код динамически записывается на страницу, и другие, где изменяется DOM или даже где скрипты непосредственно выполняются.

## Меры защиты

См. в [Памятке по предотвращению XSS на основе DOM](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).

## Ссылки

- [DomXSSWiki](https://github.com/wisec/domxsswiki/wiki/)
- [Статья Amit Klein про DOM XSS](http://www.webappsec.org/projects/articles/071105.html)
- [В поисках лазеек: гид по DOM Based XSS](https://habr.com/ru/company/xakep/blog/189210/)
- [Предотвращение DOM XSS-уязвимостей при помощи Trusted Types](https://web.dev/i18n/ru/trusted-types/)